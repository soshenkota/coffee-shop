(() => { var e = { 807: e => { var t = !("undefined" == typeof window || !window.document || !window.document.createElement); e.exports = t } }, t = {}; function s(i) { var n = t[i]; if (void 0 !== n) return n.exports; var r = t[i] = { exports: {} }; return e[i](r, r.exports, s), r.exports } (() => { "use strict"; const e = {}; let t = { Android: function () { return navigator.userAgent.match(/Android/i) }, BlackBerry: function () { return navigator.userAgent.match(/BlackBerry/i) }, iOS: function () { return navigator.userAgent.match(/iPhone|iPad|iPod/i) }, Opera: function () { return navigator.userAgent.match(/Opera Mini/i) }, Windows: function () { return navigator.userAgent.match(/IEMobile/i) }, any: function () { return t.Android() || t.BlackBerry() || t.iOS() || t.Opera() || t.Windows() } }; let i = (e, t = 500, s = 0) => { e.classList.contains("_slide") || (e.classList.add("_slide"), e.style.transitionProperty = "height, margin, padding", e.style.transitionDuration = t + "ms", e.style.height = `${e.offsetHeight}px`, e.offsetHeight, e.style.overflow = "hidden", e.style.height = s ? `${s}px` : "0px", e.style.paddingTop = 0, e.style.paddingBottom = 0, e.style.marginTop = 0, e.style.marginBottom = 0, window.setTimeout((() => { e.hidden = !s, !s && e.style.removeProperty("height"), e.style.removeProperty("padding-top"), e.style.removeProperty("padding-bottom"), e.style.removeProperty("margin-top"), e.style.removeProperty("margin-bottom"), !s && e.style.removeProperty("overflow"), e.style.removeProperty("transition-duration"), e.style.removeProperty("transition-property"), e.classList.remove("_slide"), document.dispatchEvent(new CustomEvent("slideUpDone", { detail: { target: e } })) }), t)) }, n = (e, t = 500, s = 0) => { if (!e.classList.contains("_slide")) { e.classList.add("_slide"), e.hidden = !e.hidden && null, s && e.style.removeProperty("height"); let i = e.offsetHeight; e.style.overflow = "hidden", e.style.height = s ? `${s}px` : "0px", e.style.paddingTop = 0, e.style.paddingBottom = 0, e.style.marginTop = 0, e.style.marginBottom = 0, e.offsetHeight, e.style.transitionProperty = "height, margin, padding", e.style.transitionDuration = t + "ms", e.style.height = i + "px", e.style.removeProperty("padding-top"), e.style.removeProperty("padding-bottom"), e.style.removeProperty("margin-top"), e.style.removeProperty("margin-bottom"), window.setTimeout((() => { e.style.removeProperty("height"), e.style.removeProperty("overflow"), e.style.removeProperty("transition-duration"), e.style.removeProperty("transition-property"), e.classList.remove("_slide"), document.dispatchEvent(new CustomEvent("slideDownDone", { detail: { target: e } })) }), t) } }, r = !0, o = (e = 500) => { let t = document.querySelector("body"); if (r) { let s = document.querySelectorAll("[data-lp]"); setTimeout((() => { for (let e = 0; e < s.length; e++) { s[e].style.paddingRight = "0px" } t.style.paddingRight = "0px", document.documentElement.classList.remove("lock") }), e), r = !1, setTimeout((function () { r = !0 }), e) } }, a = (e = 500) => { let t = document.querySelector("body"); if (r) { let s = document.querySelectorAll("[data-lp]"); for (let e = 0; e < s.length; e++) { s[e].style.paddingRight = window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px" } t.style.paddingRight = window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px", document.documentElement.classList.add("lock"), r = !1, setTimeout((function () { r = !0 }), e) } }; function l(e) { setTimeout((() => { window.FLS && console.log(e) }), 0) } function c(e) { return e.filter((function (e, t, s) { return s.indexOf(e) === t })) } function d(e, t) { const s = Array.from(e).filter((function (e, s, i) { if (e.dataset[t]) return e.dataset[t].split(",")[0] })); if (s.length) { const e = []; s.forEach((s => { const i = {}, n = s.dataset[t].split(","); i.value = n[0], i.type = n[1] ? n[1].trim() : "max", i.item = s, e.push(i) })); let i = e.map((function (e) { return "(" + e.type + "-width: " + e.value + "px)," + e.value + "," + e.type })); i = c(i); const n = []; if (i.length) return i.forEach((t => { const s = t.split(","), i = s[1], r = s[2], o = window.matchMedia(s[0]), a = e.filter((function (e) { if (e.value === i && e.type === r) return !0 })); n.push({ itemsArray: a, matchMedia: o }) })), n } } e.popup = new class { constructor(e) { let t = { logging: !0, init: !0, attributeOpenButton: "data-popup", attributeCloseButton: "data-close", fixElementSelector: "[data-lp]", youtubeAttribute: "data-popup-youtube", youtubePlaceAttribute: "data-popup-youtube-place", setAutoplayYoutube: !0, classes: { popup: "popup", popupContent: "popup__content", popupActive: "popup_show", bodyActive: "popup-show" }, focusCatch: !0, closeEsc: !0, bodyLock: !0, hashSettings: { location: !0, goHash: !0 }, on: { beforeOpen: function () { }, afterOpen: function () { }, beforeClose: function () { }, afterClose: function () { } } }; this.youTubeCode, this.isOpen = !1, this.targetOpen = { selector: !1, element: !1 }, this.previousOpen = { selector: !1, element: !1 }, this.lastClosed = { selector: !1, element: !1 }, this._dataValue = !1, this.hash = !1, this._reopen = !1, this._selectorOpen = !1, this.lastFocusEl = !1, this._focusEl = ["a[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "button:not([disabled]):not([aria-hidden])", "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "area[href]", "iframe", "object", "embed", "[contenteditable]", '[tabindex]:not([tabindex^="-"])'], this.options = { ...t, ...e, classes: { ...t.classes, ...e?.classes }, hashSettings: { ...t.hashSettings, ...e?.hashSettings }, on: { ...t.on, ...e?.on } }, this.bodyLock = !1, this.options.init && this.initPopups() } initPopups() { this.popupLogging("Прокинувся"), this.eventsPopup() } eventsPopup() { document.addEventListener("click", function (e) { const t = e.target.closest(`[${this.options.attributeOpenButton}]`); if (t) return e.preventDefault(), this._dataValue = t.getAttribute(this.options.attributeOpenButton) ? t.getAttribute(this.options.attributeOpenButton) : "error", this.youTubeCode = t.getAttribute(this.options.youtubeAttribute) ? t.getAttribute(this.options.youtubeAttribute) : null, "error" !== this._dataValue ? (this.isOpen || (this.lastFocusEl = t), this.targetOpen.selector = `${this._dataValue}`, this._selectorOpen = !0, void this.open()) : void this.popupLogging(`Йой, не заповнено атрибут у ${t.classList}`); return e.target.closest(`[${this.options.attributeCloseButton}]`) || !e.target.closest(`.${this.options.classes.popupContent}`) && this.isOpen ? (e.preventDefault(), void this.close()) : void 0 }.bind(this)), document.addEventListener("keydown", function (e) { if (this.options.closeEsc && 27 == e.which && "Escape" === e.code && this.isOpen) return e.preventDefault(), void this.close(); this.options.focusCatch && 9 == e.which && this.isOpen && this._focusCatch(e) }.bind(this)), this.options.hashSettings.goHash && (window.addEventListener("hashchange", function () { window.location.hash ? this._openToHash() : this.close(this.targetOpen.selector) }.bind(this)), window.addEventListener("load", function () { window.location.hash && this._openToHash() }.bind(this))) } open(e) { if (r) if (this.bodyLock = !(!document.documentElement.classList.contains("lock") || this.isOpen), e && "string" == typeof e && "" !== e.trim() && (this.targetOpen.selector = e, this._selectorOpen = !0), this.isOpen && (this._reopen = !0, this.close()), this._selectorOpen || (this.targetOpen.selector = this.lastClosed.selector), this._reopen || (this.previousActiveElement = document.activeElement), this.targetOpen.element = document.querySelector(this.targetOpen.selector), this.targetOpen.element) { if (this.youTubeCode) { const e = `https://www.youtube.com/embed/${this.youTubeCode}?rel=0&showinfo=0&autoplay=1`, t = document.createElement("iframe"); t.setAttribute("allowfullscreen", ""); const s = this.options.setAutoplayYoutube ? "autoplay;" : ""; if (t.setAttribute("allow", `${s}; encrypted-media`), t.setAttribute("src", e), !this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`)) { this.targetOpen.element.querySelector(".popup__text").setAttribute(`${this.options.youtubePlaceAttribute}`, "") } this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`).appendChild(t) } this.options.hashSettings.location && (this._getHash(), this._setHash()), this.options.on.beforeOpen(this), document.dispatchEvent(new CustomEvent("beforePopupOpen", { detail: { popup: this } })), this.targetOpen.element.classList.add(this.options.classes.popupActive), document.documentElement.classList.add(this.options.classes.bodyActive), this._reopen ? this._reopen = !1 : !this.bodyLock && a(), this.targetOpen.element.setAttribute("aria-hidden", "false"), this.previousOpen.selector = this.targetOpen.selector, this.previousOpen.element = this.targetOpen.element, this._selectorOpen = !1, this.isOpen = !0, setTimeout((() => { this._focusTrap() }), 50), this.options.on.afterOpen(this), document.dispatchEvent(new CustomEvent("afterPopupOpen", { detail: { popup: this } })), this.popupLogging("Відкрив попап") } else this.popupLogging("Йой, такого попапу немає. Перевірте коректність введення. ") } close(e) { e && "string" == typeof e && "" !== e.trim() && (this.previousOpen.selector = e), this.isOpen && r && (this.options.on.beforeClose(this), document.dispatchEvent(new CustomEvent("beforePopupClose", { detail: { popup: this } })), this.youTubeCode && this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`) && (this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`).innerHTML = ""), this.previousOpen.element.classList.remove(this.options.classes.popupActive), this.previousOpen.element.setAttribute("aria-hidden", "true"), this._reopen || (document.documentElement.classList.remove(this.options.classes.bodyActive), !this.bodyLock && o(), this.isOpen = !1), this._removeHash(), this._selectorOpen && (this.lastClosed.selector = this.previousOpen.selector, this.lastClosed.element = this.previousOpen.element), this.options.on.afterClose(this), document.dispatchEvent(new CustomEvent("afterPopupClose", { detail: { popup: this } })), setTimeout((() => { this._focusTrap() }), 50), this.popupLogging("Закрив попап")) } _getHash() { this.options.hashSettings.location && (this.hash = this.targetOpen.selector.includes("#") ? this.targetOpen.selector : this.targetOpen.selector.replace(".", "#")) } _openToHash() { let e = document.querySelector(`.${window.location.hash.replace("#", "")}`) ? `.${window.location.hash.replace("#", "")}` : document.querySelector(`${window.location.hash}`) ? `${window.location.hash}` : null; const t = document.querySelector(`[${this.options.attributeOpenButton} = "${e}"]`) ? document.querySelector(`[${this.options.attributeOpenButton} = "${e}"]`) : document.querySelector(`[${this.options.attributeOpenButton} = "${e.replace(".", "#")}"]`); this.youTubeCode = t.getAttribute(this.options.youtubeAttribute) ? t.getAttribute(this.options.youtubeAttribute) : null, t && e && this.open(e) } _setHash() { history.pushState("", "", this.hash) } _removeHash() { history.pushState("", "", window.location.href.split("#")[0]) } _focusCatch(e) { const t = this.targetOpen.element.querySelectorAll(this._focusEl), s = Array.prototype.slice.call(t), i = s.indexOf(document.activeElement); e.shiftKey && 0 === i && (s[s.length - 1].focus(), e.preventDefault()), e.shiftKey || i !== s.length - 1 || (s[0].focus(), e.preventDefault()) } _focusTrap() { const e = this.previousOpen.element.querySelectorAll(this._focusEl); !this.isOpen && this.lastFocusEl ? this.lastFocusEl.focus() : e[0].focus() } popupLogging(e) { this.options.logging && l(`[Попапос]: ${e}`) } }({}); let p = { getErrors(e) { let t = 0, s = e.querySelectorAll("*[data-required]"); return s.length && s.forEach((e => { null === e.offsetParent && "SELECT" !== e.tagName || e.disabled || (t += this.validateInput(e)) })), t }, validateInput(e) { let t = 0; return "email" === e.dataset.required ? (e.value = e.value.replace(" ", ""), this.emailTest(e) ? (this.addError(e), t++) : this.removeError(e)) : ("checkbox" !== e.type || e.checked) && e.value.trim() ? this.removeError(e) : (this.addError(e), t++), t }, addError(e) { e.classList.add("_form-error"), e.parentElement.classList.add("_form-error"); let t = e.parentElement.querySelector(".form__error"); t && e.parentElement.removeChild(t), e.dataset.error && e.parentElement.insertAdjacentHTML("beforeend", `<div class="form__error">${e.dataset.error}</div>`) }, removeError(e) { e.classList.remove("_form-error"), e.parentElement.classList.remove("_form-error"), e.parentElement.querySelector(".form__error") && e.parentElement.removeChild(e.parentElement.querySelector(".form__error")) }, formClean(t) { t.reset(), setTimeout((() => { let s = t.querySelectorAll("input,textarea"); for (let e = 0; e < s.length; e++) { const t = s[e]; t.parentElement.classList.remove("_form-focus"), t.classList.remove("_form-focus"), p.removeError(t) } let i = t.querySelectorAll(".checkbox__input"); if (i.length > 0) for (let e = 0; e < i.length; e++) { i[e].checked = !1 } if (e.select) { let s = t.querySelectorAll(".select"); if (s.length) for (let t = 0; t < s.length; t++) { const i = s[t].querySelector("select"); e.select.selectBuild(i) } } }), 0) }, emailTest: e => !/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,8})+$/.test(e.value) }; function h(e) { return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object } function u(e, t) { void 0 === e && (e = {}), void 0 === t && (t = {}), Object.keys(t).forEach((s => { void 0 === e[s] ? e[s] = t[s] : h(t[s]) && h(e[s]) && Object.keys(t[s]).length > 0 && u(e[s], t[s]) })) } const m = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector: () => null, querySelectorAll: () => [], getElementById: () => null, createEvent: () => ({ initEvent() { } }), createElement: () => ({ children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName: () => [] }), createElementNS: () => ({}), importNode: () => null, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; function f() { const e = "undefined" != typeof document ? document : {}; return u(e, m), e } const v = { document: m, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle: () => ({ getPropertyValue: () => "" }), Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia: () => ({}), requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0), cancelAnimationFrame(e) { "undefined" != typeof setTimeout && clearTimeout(e) } }; function g() { const e = "undefined" != typeof window ? window : {}; return u(e, v), e } function b(e, t) { return void 0 === t && (t = 0), setTimeout(e, t) } function w() { return Date.now() } function y(e, t) { void 0 === t && (t = "x"); const s = g(); let i, n, r; const o = function (e) { const t = g(); let s; return t.getComputedStyle && (s = t.getComputedStyle(e, null)), !s && e.currentStyle && (s = e.currentStyle), s || (s = e.style), s }(e); return s.WebKitCSSMatrix ? (n = o.transform || o.webkitTransform, n.split(",").length > 6 && (n = n.split(", ").map((e => e.replace(",", "."))).join(", ")), r = new s.WebKitCSSMatrix("none" === n ? "" : n)) : (r = o.MozTransform || o.OTransform || o.MsTransform || o.msTransform || o.transform || o.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), i = r.toString().split(",")), "x" === t && (n = s.WebKitCSSMatrix ? r.m41 : 16 === i.length ? parseFloat(i[12]) : parseFloat(i[4])), "y" === t && (n = s.WebKitCSSMatrix ? r.m42 : 16 === i.length ? parseFloat(i[13]) : parseFloat(i[5])), n || 0 } function E(e) { return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1) } function S() { const e = Object(arguments.length <= 0 ? void 0 : arguments[0]), t = ["__proto__", "constructor", "prototype"]; for (let i = 1; i < arguments.length; i += 1) { const n = i < 0 || arguments.length <= i ? void 0 : arguments[i]; if (null != n && (s = n, !("undefined" != typeof window && void 0 !== window.HTMLElement ? s instanceof HTMLElement : s && (1 === s.nodeType || 11 === s.nodeType)))) { const s = Object.keys(Object(n)).filter((e => t.indexOf(e) < 0)); for (let t = 0, i = s.length; t < i; t += 1) { const i = s[t], r = Object.getOwnPropertyDescriptor(n, i); void 0 !== r && r.enumerable && (E(e[i]) && E(n[i]) ? n[i].__swiper__ ? e[i] = n[i] : S(e[i], n[i]) : !E(e[i]) && E(n[i]) ? (e[i] = {}, n[i].__swiper__ ? e[i] = n[i] : S(e[i], n[i])) : e[i] = n[i]) } } } var s; return e } function x(e, t, s) { e.style.setProperty(t, s) } function T(e) { let { swiper: t, targetPosition: s, side: i } = e; const n = g(), r = -t.translate; let o, a = null; const l = t.params.speed; t.wrapperEl.style.scrollSnapType = "none", n.cancelAnimationFrame(t.cssModeFrameID); const c = s > r ? "next" : "prev", d = (e, t) => "next" === c && e >= t || "prev" === c && e <= t, p = () => { o = (new Date).getTime(), null === a && (a = o); const e = Math.max(Math.min((o - a) / l, 1), 0), c = .5 - Math.cos(e * Math.PI) / 2; let h = r + c * (s - r); if (d(h, s) && (h = s), t.wrapperEl.scrollTo({ [i]: h }), d(h, s)) return t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout((() => { t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({ [i]: h }) })), void n.cancelAnimationFrame(t.cssModeFrameID); t.cssModeFrameID = n.requestAnimationFrame(p) }; p() } function C(e, t) { return void 0 === t && (t = ""), [...e.children].filter((e => e.matches(t))) } function L(e, t) { void 0 === t && (t = []); const s = document.createElement(e); return s.classList.add(...Array.isArray(t) ? t : [t]), s } function O(e, t) { return g().getComputedStyle(e, null).getPropertyValue(t) } function A(e) { let t, s = e; if (s) { for (t = 0; null !== (s = s.previousSibling);)1 === s.nodeType && (t += 1); return t } } function M(e, t) { const s = []; let i = e.parentElement; for (; i;)t ? i.matches(t) && s.push(i) : s.push(i), i = i.parentElement; return s } function k(e, t, s) { const i = g(); return s ? e["width" === t ? "offsetWidth" : "offsetHeight"] + parseFloat(i.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-right" : "margin-top")) + parseFloat(i.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-left" : "margin-bottom")) : e.offsetWidth } let P, _, I; function z() { return P || (P = function () { const e = g(), t = f(); return { smoothScroll: t.documentElement && t.documentElement.style && "scrollBehavior" in t.documentElement.style, touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch) } }()), P } function W(e) { return void 0 === e && (e = {}), _ || (_ = function (e) { let { userAgent: t } = void 0 === e ? {} : e; const s = z(), i = g(), n = i.navigator.platform, r = t || i.navigator.userAgent, o = { ios: !1, android: !1 }, a = i.screen.width, l = i.screen.height, c = r.match(/(Android);?[\s\/]+([\d.]+)?/); let d = r.match(/(iPad).*OS\s([\d_]+)/); const p = r.match(/(iPod)(.*OS\s([\d_]+))?/), h = !d && r.match(/(iPhone\sOS|iOS)\s([\d_]+)/), u = "Win32" === n; let m = "MacIntel" === n; return !d && m && s.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${a}x${l}`) >= 0 && (d = r.match(/(Version)\/([\d.]+)/), d || (d = [0, 1, "13_0_0"]), m = !1), c && !u && (o.os = "android", o.android = !0), (d || h || p) && (o.os = "ios", o.ios = !0), o }(e)), _ } function D() { return I || (I = function () { const e = g(); let t = !1; function s() { const t = e.navigator.userAgent.toLowerCase(); return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0 } if (s()) { const s = String(e.navigator.userAgent); if (s.includes("Version/")) { const [e, i] = s.split("Version/")[1].split(" ")[0].split(".").map((e => Number(e))); t = e < 16 || 16 === e && i < 2 } } return { isSafari: t || s(), needPerspectiveFix: t, isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent) } }()), I } var N = { on(e, t, s) { const i = this; if (!i.eventsListeners || i.destroyed) return i; if ("function" != typeof t) return i; const n = s ? "unshift" : "push"; return e.split(" ").forEach((e => { i.eventsListeners[e] || (i.eventsListeners[e] = []), i.eventsListeners[e][n](t) })), i }, once(e, t, s) { const i = this; if (!i.eventsListeners || i.destroyed) return i; if ("function" != typeof t) return i; function n() { i.off(e, n), n.__emitterProxy && delete n.__emitterProxy; for (var s = arguments.length, r = new Array(s), o = 0; o < s; o++)r[o] = arguments[o]; t.apply(i, r) } return n.__emitterProxy = t, i.on(e, n, s) }, onAny(e, t) { const s = this; if (!s.eventsListeners || s.destroyed) return s; if ("function" != typeof e) return s; const i = t ? "unshift" : "push"; return s.eventsAnyListeners.indexOf(e) < 0 && s.eventsAnyListeners[i](e), s }, offAny(e) { const t = this; if (!t.eventsListeners || t.destroyed) return t; if (!t.eventsAnyListeners) return t; const s = t.eventsAnyListeners.indexOf(e); return s >= 0 && t.eventsAnyListeners.splice(s, 1), t }, off(e, t) { const s = this; return !s.eventsListeners || s.destroyed ? s : s.eventsListeners ? (e.split(" ").forEach((e => { void 0 === t ? s.eventsListeners[e] = [] : s.eventsListeners[e] && s.eventsListeners[e].forEach(((i, n) => { (i === t || i.__emitterProxy && i.__emitterProxy === t) && s.eventsListeners[e].splice(n, 1) })) })), s) : s }, emit() { const e = this; if (!e.eventsListeners || e.destroyed) return e; if (!e.eventsListeners) return e; let t, s, i; for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)r[o] = arguments[o]; "string" == typeof r[0] || Array.isArray(r[0]) ? (t = r[0], s = r.slice(1, r.length), i = e) : (t = r[0].events, s = r[0].data, i = r[0].context || e), s.unshift(i); return (Array.isArray(t) ? t : t.split(" ")).forEach((t => { e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach((e => { e.apply(i, [t, ...s]) })), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach((e => { e.apply(i, s) })) })), e } }; const $ = (e, t) => { if (!e || e.destroyed || !e.params) return; const s = t.closest(e.isElement ? "swiper-slide" : `.${e.params.slideClass}`); if (s) { const t = s.querySelector(`.${e.params.lazyPreloaderClass}`); t && t.remove() } }, B = (e, t) => { if (!e.slides[t]) return; const s = e.slides[t].querySelector('[loading="lazy"]'); s && s.removeAttribute("loading") }, H = e => { if (!e || e.destroyed || !e.params) return; let t = e.params.lazyPreloadPrevNext; const s = e.slides.length; if (!s || !t || t < 0) return; t = Math.min(t, s); const i = "auto" === e.params.slidesPerView ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView), n = e.activeIndex; if (e.params.grid && e.params.grid.rows > 1) { const s = n, r = [s - t]; return r.push(...Array.from({ length: t }).map(((e, t) => s + i + t))), void e.slides.forEach(((t, s) => { r.includes(t.column) && B(e, s) })) } const r = n + i - 1; if (e.params.rewind || e.params.loop) for (let i = n - t; i <= r + t; i += 1) { const t = (i % s + s) % s; (t < n || t > r) && B(e, t) } else for (let i = Math.max(n - t, 0); i <= Math.min(r + t, s - 1); i += 1)i !== n && (i > r || i < n) && B(e, i) }; var G = { updateSize: function () { const e = this; let t, s; const i = e.el; t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : i.clientWidth, s = void 0 !== e.params.height && null !== e.params.height ? e.params.height : i.clientHeight, 0 === t && e.isHorizontal() || 0 === s && e.isVertical() || (t = t - parseInt(O(i, "padding-left") || 0, 10) - parseInt(O(i, "padding-right") || 0, 10), s = s - parseInt(O(i, "padding-top") || 0, 10) - parseInt(O(i, "padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(s) && (s = 0), Object.assign(e, { width: t, height: s, size: e.isHorizontal() ? t : s })) }, updateSlides: function () { const e = this; function t(t) { return e.isHorizontal() ? t : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[t] } function s(e, s) { return parseFloat(e.getPropertyValue(t(s)) || 0) } const i = e.params, { wrapperEl: n, slidesEl: r, size: o, rtlTranslate: a, wrongRTL: l } = e, c = e.virtual && i.virtual.enabled, d = c ? e.virtual.slides.length : e.slides.length, p = C(r, `.${e.params.slideClass}, swiper-slide`), h = c ? e.virtual.slides.length : p.length; let u = []; const m = [], f = []; let v = i.slidesOffsetBefore; "function" == typeof v && (v = i.slidesOffsetBefore.call(e)); let g = i.slidesOffsetAfter; "function" == typeof g && (g = i.slidesOffsetAfter.call(e)); const b = e.snapGrid.length, w = e.slidesGrid.length; let y = i.spaceBetween, E = -v, S = 0, T = 0; if (void 0 === o) return; "string" == typeof y && y.indexOf("%") >= 0 ? y = parseFloat(y.replace("%", "")) / 100 * o : "string" == typeof y && (y = parseFloat(y)), e.virtualSize = -y, p.forEach((e => { a ? e.style.marginLeft = "" : e.style.marginRight = "", e.style.marginBottom = "", e.style.marginTop = "" })), i.centeredSlides && i.cssMode && (x(n, "--swiper-centered-offset-before", ""), x(n, "--swiper-centered-offset-after", "")); const L = i.grid && i.grid.rows > 1 && e.grid; let A; L && e.grid.initSlides(h); const M = "auto" === i.slidesPerView && i.breakpoints && Object.keys(i.breakpoints).filter((e => void 0 !== i.breakpoints[e].slidesPerView)).length > 0; for (let n = 0; n < h; n += 1) { let r; if (A = 0, p[n] && (r = p[n]), L && e.grid.updateSlide(n, r, h, t), !p[n] || "none" !== O(r, "display")) { if ("auto" === i.slidesPerView) { M && (p[n].style[t("width")] = ""); const o = getComputedStyle(r), a = r.style.transform, l = r.style.webkitTransform; if (a && (r.style.transform = "none"), l && (r.style.webkitTransform = "none"), i.roundLengths) A = e.isHorizontal() ? k(r, "width", !0) : k(r, "height", !0); else { const e = s(o, "width"), t = s(o, "padding-left"), i = s(o, "padding-right"), n = s(o, "margin-left"), a = s(o, "margin-right"), l = o.getPropertyValue("box-sizing"); if (l && "border-box" === l) A = e + n + a; else { const { clientWidth: s, offsetWidth: o } = r; A = e + t + i + n + a + (o - s) } } a && (r.style.transform = a), l && (r.style.webkitTransform = l), i.roundLengths && (A = Math.floor(A)) } else A = (o - (i.slidesPerView - 1) * y) / i.slidesPerView, i.roundLengths && (A = Math.floor(A)), p[n] && (p[n].style[t("width")] = `${A}px`); p[n] && (p[n].swiperSlideSize = A), f.push(A), i.centeredSlides ? (E = E + A / 2 + S / 2 + y, 0 === S && 0 !== n && (E = E - o / 2 - y), 0 === n && (E = E - o / 2 - y), Math.abs(E) < .001 && (E = 0), i.roundLengths && (E = Math.floor(E)), T % i.slidesPerGroup == 0 && u.push(E), m.push(E)) : (i.roundLengths && (E = Math.floor(E)), (T - Math.min(e.params.slidesPerGroupSkip, T)) % e.params.slidesPerGroup == 0 && u.push(E), m.push(E), E = E + A + y), e.virtualSize += A + y, S = A, T += 1 } } if (e.virtualSize = Math.max(e.virtualSize, o) + g, a && l && ("slide" === i.effect || "coverflow" === i.effect) && (n.style.width = `${e.virtualSize + y}px`), i.setWrapperSize && (n.style[t("width")] = `${e.virtualSize + y}px`), L && e.grid.updateWrapperSize(A, u, t), !i.centeredSlides) { const t = []; for (let s = 0; s < u.length; s += 1) { let n = u[s]; i.roundLengths && (n = Math.floor(n)), u[s] <= e.virtualSize - o && t.push(n) } u = t, Math.floor(e.virtualSize - o) - Math.floor(u[u.length - 1]) > 1 && u.push(e.virtualSize - o) } if (c && i.loop) { const t = f[0] + y; if (i.slidesPerGroup > 1) { const s = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / i.slidesPerGroup), n = t * i.slidesPerGroup; for (let e = 0; e < s; e += 1)u.push(u[u.length - 1] + n) } for (let s = 0; s < e.virtual.slidesBefore + e.virtual.slidesAfter; s += 1)1 === i.slidesPerGroup && u.push(u[u.length - 1] + t), m.push(m[m.length - 1] + t), e.virtualSize += t } if (0 === u.length && (u = [0]), 0 !== y) { const s = e.isHorizontal() && a ? "marginLeft" : t("marginRight"); p.filter(((e, t) => !(i.cssMode && !i.loop) || t !== p.length - 1)).forEach((e => { e.style[s] = `${y}px` })) } if (i.centeredSlides && i.centeredSlidesBounds) { let e = 0; f.forEach((t => { e += t + (y || 0) })), e -= y; const t = e - o; u = u.map((e => e <= 0 ? -v : e > t ? t + g : e)) } if (i.centerInsufficientSlides) { let e = 0; if (f.forEach((t => { e += t + (y || 0) })), e -= y, e < o) { const t = (o - e) / 2; u.forEach(((e, s) => { u[s] = e - t })), m.forEach(((e, s) => { m[s] = e + t })) } } if (Object.assign(e, { slides: p, snapGrid: u, slidesGrid: m, slidesSizesGrid: f }), i.centeredSlides && i.cssMode && !i.centeredSlidesBounds) { x(n, "--swiper-centered-offset-before", -u[0] + "px"), x(n, "--swiper-centered-offset-after", e.size / 2 - f[f.length - 1] / 2 + "px"); const t = -e.snapGrid[0], s = -e.slidesGrid[0]; e.snapGrid = e.snapGrid.map((e => e + t)), e.slidesGrid = e.slidesGrid.map((e => e + s)) } if (h !== d && e.emit("slidesLengthChange"), u.length !== b && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), m.length !== w && e.emit("slidesGridLengthChange"), i.watchSlidesProgress && e.updateSlidesOffset(), !(c || i.cssMode || "slide" !== i.effect && "fade" !== i.effect)) { const t = `${i.containerModifierClass}backface-hidden`, s = e.el.classList.contains(t); h <= i.maxBackfaceHiddenSlides ? s || e.el.classList.add(t) : s && e.el.classList.remove(t) } }, updateAutoHeight: function (e) { const t = this, s = [], i = t.virtual && t.params.virtual.enabled; let n, r = 0; "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed); const o = e => i ? t.slides[t.getSlideIndexByData(e)] : t.slides[e]; if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1) if (t.params.centeredSlides) (t.visibleSlides || []).forEach((e => { s.push(e) })); else for (n = 0; n < Math.ceil(t.params.slidesPerView); n += 1) { const e = t.activeIndex + n; if (e > t.slides.length && !i) break; s.push(o(e)) } else s.push(o(t.activeIndex)); for (n = 0; n < s.length; n += 1)if (void 0 !== s[n]) { const e = s[n].offsetHeight; r = e > r ? e : r } (r || 0 === r) && (t.wrapperEl.style.height = `${r}px`) }, updateSlidesOffset: function () { const e = this, t = e.slides, s = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0; for (let i = 0; i < t.length; i += 1)t[i].swiperSlideOffset = (e.isHorizontal() ? t[i].offsetLeft : t[i].offsetTop) - s - e.cssOverflowAdjustment() }, updateSlidesProgress: function (e) { void 0 === e && (e = this && this.translate || 0); const t = this, s = t.params, { slides: i, rtlTranslate: n, snapGrid: r } = t; if (0 === i.length) return; void 0 === i[0].swiperSlideOffset && t.updateSlidesOffset(); let o = -e; n && (o = e), i.forEach((e => { e.classList.remove(s.slideVisibleClass) })), t.visibleSlidesIndexes = [], t.visibleSlides = []; let a = s.spaceBetween; "string" == typeof a && a.indexOf("%") >= 0 ? a = parseFloat(a.replace("%", "")) / 100 * t.size : "string" == typeof a && (a = parseFloat(a)); for (let e = 0; e < i.length; e += 1) { const l = i[e]; let c = l.swiperSlideOffset; s.cssMode && s.centeredSlides && (c -= i[0].swiperSlideOffset); const d = (o + (s.centeredSlides ? t.minTranslate() : 0) - c) / (l.swiperSlideSize + a), p = (o - r[0] + (s.centeredSlides ? t.minTranslate() : 0) - c) / (l.swiperSlideSize + a), h = -(o - c), u = h + t.slidesSizesGrid[e]; (h >= 0 && h < t.size - 1 || u > 1 && u <= t.size || h <= 0 && u >= t.size) && (t.visibleSlides.push(l), t.visibleSlidesIndexes.push(e), i[e].classList.add(s.slideVisibleClass)), l.progress = n ? -d : d, l.originalProgress = n ? -p : p } }, updateProgress: function (e) { const t = this; if (void 0 === e) { const s = t.rtlTranslate ? -1 : 1; e = t && t.translate && t.translate * s || 0 } const s = t.params, i = t.maxTranslate() - t.minTranslate(); let { progress: n, isBeginning: r, isEnd: o, progressLoop: a } = t; const l = r, c = o; if (0 === i) n = 0, r = !0, o = !0; else { n = (e - t.minTranslate()) / i; const s = Math.abs(e - t.minTranslate()) < 1, a = Math.abs(e - t.maxTranslate()) < 1; r = s || n <= 0, o = a || n >= 1, s && (n = 0), a && (n = 1) } if (s.loop) { const s = t.getSlideIndexByData(0), i = t.getSlideIndexByData(t.slides.length - 1), n = t.slidesGrid[s], r = t.slidesGrid[i], o = t.slidesGrid[t.slidesGrid.length - 1], l = Math.abs(e); a = l >= n ? (l - n) / o : (l + o - r) / o, a > 1 && (a -= 1) } Object.assign(t, { progress: n, progressLoop: a, isBeginning: r, isEnd: o }), (s.watchSlidesProgress || s.centeredSlides && s.autoHeight) && t.updateSlidesProgress(e), r && !l && t.emit("reachBeginning toEdge"), o && !c && t.emit("reachEnd toEdge"), (l && !r || c && !o) && t.emit("fromEdge"), t.emit("progress", n) }, updateSlidesClasses: function () { const e = this, { slides: t, params: s, slidesEl: i, activeIndex: n } = e, r = e.virtual && s.virtual.enabled, o = e => C(i, `.${s.slideClass}${e}, swiper-slide${e}`)[0]; let a; if (t.forEach((e => { e.classList.remove(s.slideActiveClass, s.slideNextClass, s.slidePrevClass) })), r) if (s.loop) { let t = n - e.virtual.slidesBefore; t < 0 && (t = e.virtual.slides.length + t), t >= e.virtual.slides.length && (t -= e.virtual.slides.length), a = o(`[data-swiper-slide-index="${t}"]`) } else a = o(`[data-swiper-slide-index="${n}"]`); else a = t[n]; if (a) { a.classList.add(s.slideActiveClass); let e = function (e, t) { const s = []; for (; e.nextElementSibling;) { const i = e.nextElementSibling; t ? i.matches(t) && s.push(i) : s.push(i), e = i } return s }(a, `.${s.slideClass}, swiper-slide`)[0]; s.loop && !e && (e = t[0]), e && e.classList.add(s.slideNextClass); let i = function (e, t) { const s = []; for (; e.previousElementSibling;) { const i = e.previousElementSibling; t ? i.matches(t) && s.push(i) : s.push(i), e = i } return s }(a, `.${s.slideClass}, swiper-slide`)[0]; s.loop && 0 === !i && (i = t[t.length - 1]), i && i.classList.add(s.slidePrevClass) } e.emitSlidesClasses() }, updateActiveIndex: function (e) { const t = this, s = t.rtlTranslate ? t.translate : -t.translate, { snapGrid: i, params: n, activeIndex: r, realIndex: o, snapIndex: a } = t; let l, c = e; const d = e => { let s = e - t.virtual.slidesBefore; return s < 0 && (s = t.virtual.slides.length + s), s >= t.virtual.slides.length && (s -= t.virtual.slides.length), s }; if (void 0 === c && (c = function (e) { const { slidesGrid: t, params: s } = e, i = e.rtlTranslate ? e.translate : -e.translate; let n; for (let e = 0; e < t.length; e += 1)void 0 !== t[e + 1] ? i >= t[e] && i < t[e + 1] - (t[e + 1] - t[e]) / 2 ? n = e : i >= t[e] && i < t[e + 1] && (n = e + 1) : i >= t[e] && (n = e); return s.normalizeSlideIndex && (n < 0 || void 0 === n) && (n = 0), n }(t)), i.indexOf(s) >= 0) l = i.indexOf(s); else { const e = Math.min(n.slidesPerGroupSkip, c); l = e + Math.floor((c - e) / n.slidesPerGroup) } if (l >= i.length && (l = i.length - 1), c === r) return l !== a && (t.snapIndex = l, t.emit("snapIndexChange")), void (t.params.loop && t.virtual && t.params.virtual.enabled && (t.realIndex = d(c))); let p; p = t.virtual && n.virtual.enabled && n.loop ? d(c) : t.slides[c] ? parseInt(t.slides[c].getAttribute("data-swiper-slide-index") || c, 10) : c, Object.assign(t, { previousSnapIndex: a, snapIndex: l, previousRealIndex: o, realIndex: p, previousIndex: r, activeIndex: c }), t.initialized && H(t), t.emit("activeIndexChange"), t.emit("snapIndexChange"), o !== p && t.emit("realIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange") }, updateClickedSlide: function (e) { const t = this, s = t.params, i = e.closest(`.${s.slideClass}, swiper-slide`); let n, r = !1; if (i) for (let e = 0; e < t.slides.length; e += 1)if (t.slides[e] === i) { r = !0, n = e; break } if (!i || !r) return t.clickedSlide = void 0, void (t.clickedIndex = void 0); t.clickedSlide = i, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(i.getAttribute("data-swiper-slide-index"), 10) : t.clickedIndex = n, s.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide() } }; var q = { getTranslate: function (e) { void 0 === e && (e = this.isHorizontal() ? "x" : "y"); const { params: t, rtlTranslate: s, translate: i, wrapperEl: n } = this; if (t.virtualTranslate) return s ? -i : i; if (t.cssMode) return i; let r = y(n, e); return r += this.cssOverflowAdjustment(), s && (r = -r), r || 0 }, setTranslate: function (e, t) { const s = this, { rtlTranslate: i, params: n, wrapperEl: r, progress: o } = s; let a, l = 0, c = 0; s.isHorizontal() ? l = i ? -e : e : c = e, n.roundLengths && (l = Math.floor(l), c = Math.floor(c)), s.previousTranslate = s.translate, s.translate = s.isHorizontal() ? l : c, n.cssMode ? r[s.isHorizontal() ? "scrollLeft" : "scrollTop"] = s.isHorizontal() ? -l : -c : n.virtualTranslate || (s.isHorizontal() ? l -= s.cssOverflowAdjustment() : c -= s.cssOverflowAdjustment(), r.style.transform = `translate3d(${l}px, ${c}px, 0px)`); const d = s.maxTranslate() - s.minTranslate(); a = 0 === d ? 0 : (e - s.minTranslate()) / d, a !== o && s.updateProgress(e), s.emit("setTranslate", s.translate, t) }, minTranslate: function () { return -this.snapGrid[0] }, maxTranslate: function () { return -this.snapGrid[this.snapGrid.length - 1] }, translateTo: function (e, t, s, i, n) { void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), void 0 === i && (i = !0); const r = this, { params: o, wrapperEl: a } = r; if (r.animating && o.preventInteractionOnTransition) return !1; const l = r.minTranslate(), c = r.maxTranslate(); let d; if (d = i && e > l ? l : i && e < c ? c : e, r.updateProgress(d), o.cssMode) { const e = r.isHorizontal(); if (0 === t) a[e ? "scrollLeft" : "scrollTop"] = -d; else { if (!r.support.smoothScroll) return T({ swiper: r, targetPosition: -d, side: e ? "left" : "top" }), !0; a.scrollTo({ [e ? "left" : "top"]: -d, behavior: "smooth" }) } return !0 } return 0 === t ? (r.setTransition(0), r.setTranslate(d), s && (r.emit("beforeTransitionStart", t, n), r.emit("transitionEnd"))) : (r.setTransition(t), r.setTranslate(d), s && (r.emit("beforeTransitionStart", t, n), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function (e) { r && !r.destroyed && e.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, s && r.emit("transitionEnd")) }), r.wrapperEl.addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd))), !0 } }; function V(e) { let { swiper: t, runCallbacks: s, direction: i, step: n } = e; const { activeIndex: r, previousIndex: o } = t; let a = i; if (a || (a = r > o ? "next" : r < o ? "prev" : "reset"), t.emit(`transition${n}`), s && r !== o) { if ("reset" === a) return void t.emit(`slideResetTransition${n}`); t.emit(`slideChangeTransition${n}`), "next" === a ? t.emit(`slideNextTransition${n}`) : t.emit(`slidePrevTransition${n}`) } } var F = { slideTo: function (e, t, s, i, n) { void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), "string" == typeof e && (e = parseInt(e, 10)); const r = this; let o = e; o < 0 && (o = 0); const { params: a, snapGrid: l, slidesGrid: c, previousIndex: d, activeIndex: p, rtlTranslate: h, wrapperEl: u, enabled: m } = r; if (r.animating && a.preventInteractionOnTransition || !m && !i && !n) return !1; const f = Math.min(r.params.slidesPerGroupSkip, o); let v = f + Math.floor((o - f) / r.params.slidesPerGroup); v >= l.length && (v = l.length - 1); const g = -l[v]; if (a.normalizeSlideIndex) for (let e = 0; e < c.length; e += 1) { const t = -Math.floor(100 * g), s = Math.floor(100 * c[e]), i = Math.floor(100 * c[e + 1]); void 0 !== c[e + 1] ? t >= s && t < i - (i - s) / 2 ? o = e : t >= s && t < i && (o = e + 1) : t >= s && (o = e) } if (r.initialized && o !== p) { if (!r.allowSlideNext && (h ? g > r.translate && g > r.minTranslate() : g < r.translate && g < r.minTranslate())) return !1; if (!r.allowSlidePrev && g > r.translate && g > r.maxTranslate() && (p || 0) !== o) return !1 } let b; if (o !== (d || 0) && s && r.emit("beforeSlideChangeStart"), r.updateProgress(g), b = o > p ? "next" : o < p ? "prev" : "reset", h && -g === r.translate || !h && g === r.translate) return r.updateActiveIndex(o), a.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), "slide" !== a.effect && r.setTranslate(g), "reset" !== b && (r.transitionStart(s, b), r.transitionEnd(s, b)), !1; if (a.cssMode) { const e = r.isHorizontal(), s = h ? g : -g; if (0 === t) { const t = r.virtual && r.params.virtual.enabled; t && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), t && !r._cssModeVirtualInitialSet && r.params.initialSlide > 0 ? (r._cssModeVirtualInitialSet = !0, requestAnimationFrame((() => { u[e ? "scrollLeft" : "scrollTop"] = s }))) : u[e ? "scrollLeft" : "scrollTop"] = s, t && requestAnimationFrame((() => { r.wrapperEl.style.scrollSnapType = "", r._immediateVirtual = !1 })) } else { if (!r.support.smoothScroll) return T({ swiper: r, targetPosition: s, side: e ? "left" : "top" }), !0; u.scrollTo({ [e ? "left" : "top"]: s, behavior: "smooth" }) } return !0 } return r.setTransition(t), r.setTranslate(g), r.updateActiveIndex(o), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, i), r.transitionStart(s, b), 0 === t ? r.transitionEnd(s, b) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function (e) { r && !r.destroyed && e.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(s, b)) }), r.wrapperEl.addEventListener("transitionend", r.onSlideToWrapperTransitionEnd)), !0 }, slideToLoop: function (e, t, s, i) { if (void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), "string" == typeof e) { e = parseInt(e, 10) } const n = this; let r = e; return n.params.loop && (n.virtual && n.params.virtual.enabled ? r += n.virtual.slidesBefore : r = n.getSlideIndexByData(r)), n.slideTo(r, t, s, i) }, slideNext: function (e, t, s) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const i = this, { enabled: n, params: r, animating: o } = i; if (!n) return i; let a = r.slidesPerGroup; "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (a = Math.max(i.slidesPerViewDynamic("current", !0), 1)); const l = i.activeIndex < r.slidesPerGroupSkip ? 1 : a, c = i.virtual && r.virtual.enabled; if (r.loop) { if (o && !c && r.loopPreventsSliding) return !1; i.loopFix({ direction: "next" }), i._clientLeft = i.wrapperEl.clientLeft } return r.rewind && i.isEnd ? i.slideTo(0, e, t, s) : i.slideTo(i.activeIndex + l, e, t, s) }, slidePrev: function (e, t, s) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const i = this, { params: n, snapGrid: r, slidesGrid: o, rtlTranslate: a, enabled: l, animating: c } = i; if (!l) return i; const d = i.virtual && n.virtual.enabled; if (n.loop) { if (c && !d && n.loopPreventsSliding) return !1; i.loopFix({ direction: "prev" }), i._clientLeft = i.wrapperEl.clientLeft } function p(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e) } const h = p(a ? i.translate : -i.translate), u = r.map((e => p(e))); let m = r[u.indexOf(h) - 1]; if (void 0 === m && n.cssMode) { let e; r.forEach(((t, s) => { h >= t && (e = s) })), void 0 !== e && (m = r[e > 0 ? e - 1 : e]) } let f = 0; if (void 0 !== m && (f = o.indexOf(m), f < 0 && (f = i.activeIndex - 1), "auto" === n.slidesPerView && 1 === n.slidesPerGroup && n.slidesPerGroupAuto && (f = f - i.slidesPerViewDynamic("previous", !0) + 1, f = Math.max(f, 0))), n.rewind && i.isBeginning) { const n = i.params.virtual && i.params.virtual.enabled && i.virtual ? i.virtual.slides.length - 1 : i.slides.length - 1; return i.slideTo(n, e, t, s) } return i.slideTo(f, e, t, s) }, slideReset: function (e, t, s) { return void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), this.slideTo(this.activeIndex, e, t, s) }, slideToClosest: function (e, t, s, i) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), void 0 === i && (i = .5); const n = this; let r = n.activeIndex; const o = Math.min(n.params.slidesPerGroupSkip, r), a = o + Math.floor((r - o) / n.params.slidesPerGroup), l = n.rtlTranslate ? n.translate : -n.translate; if (l >= n.snapGrid[a]) { const e = n.snapGrid[a]; l - e > (n.snapGrid[a + 1] - e) * i && (r += n.params.slidesPerGroup) } else { const e = n.snapGrid[a - 1]; l - e <= (n.snapGrid[a] - e) * i && (r -= n.params.slidesPerGroup) } return r = Math.max(r, 0), r = Math.min(r, n.slidesGrid.length - 1), n.slideTo(r, e, t, s) }, slideToClickedSlide: function () { const e = this, { params: t, slidesEl: s } = e, i = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView; let n, r = e.clickedIndex; const o = e.isElement ? "swiper-slide" : `.${t.slideClass}`; if (t.loop) { if (e.animating) return; n = parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10), t.centeredSlides ? r < e.loopedSlides - i / 2 || r > e.slides.length - e.loopedSlides + i / 2 ? (e.loopFix(), r = e.getSlideIndex(C(s, `${o}[data-swiper-slide-index="${n}"]`)[0]), b((() => { e.slideTo(r) }))) : e.slideTo(r) : r > e.slides.length - i ? (e.loopFix(), r = e.getSlideIndex(C(s, `${o}[data-swiper-slide-index="${n}"]`)[0]), b((() => { e.slideTo(r) }))) : e.slideTo(r) } else e.slideTo(r) } }; var R = { loopCreate: function (e) { const t = this, { params: s, slidesEl: i } = t; if (!s.loop || t.virtual && t.params.virtual.enabled) return; C(i, `.${s.slideClass}, swiper-slide`).forEach(((e, t) => { e.setAttribute("data-swiper-slide-index", t) })), t.loopFix({ slideRealIndex: e, direction: s.centeredSlides ? void 0 : "next" }) }, loopFix: function (e) { let { slideRealIndex: t, slideTo: s = !0, direction: i, setTranslate: n, activeSlideIndex: r, byController: o, byMousewheel: a } = void 0 === e ? {} : e; const l = this; if (!l.params.loop) return; l.emit("beforeLoopFix"); const { slides: c, allowSlidePrev: d, allowSlideNext: p, slidesEl: h, params: u } = l; if (l.allowSlidePrev = !0, l.allowSlideNext = !0, l.virtual && u.virtual.enabled) return s && (u.centeredSlides || 0 !== l.snapIndex ? u.centeredSlides && l.snapIndex < u.slidesPerView ? l.slideTo(l.virtual.slides.length + l.snapIndex, 0, !1, !0) : l.snapIndex === l.snapGrid.length - 1 && l.slideTo(l.virtual.slidesBefore, 0, !1, !0) : l.slideTo(l.virtual.slides.length, 0, !1, !0)), l.allowSlidePrev = d, l.allowSlideNext = p, void l.emit("loopFix"); const m = "auto" === u.slidesPerView ? l.slidesPerViewDynamic() : Math.ceil(parseFloat(u.slidesPerView, 10)); let f = u.loopedSlides || m; f % u.slidesPerGroup != 0 && (f += u.slidesPerGroup - f % u.slidesPerGroup), l.loopedSlides = f; const v = [], g = []; let b = l.activeIndex; void 0 === r ? r = l.getSlideIndex(l.slides.filter((e => e.classList.contains(u.slideActiveClass)))[0]) : b = r; const w = "next" === i || !i, y = "prev" === i || !i; let E = 0, S = 0; if (r < f) { E = Math.max(f - r, u.slidesPerGroup); for (let e = 0; e < f - r; e += 1) { const t = e - Math.floor(e / c.length) * c.length; v.push(c.length - t - 1) } } else if (r > l.slides.length - 2 * f) { S = Math.max(r - (l.slides.length - 2 * f), u.slidesPerGroup); for (let e = 0; e < S; e += 1) { const t = e - Math.floor(e / c.length) * c.length; g.push(t) } } if (y && v.forEach((e => { l.slides[e].swiperLoopMoveDOM = !0, h.prepend(l.slides[e]), l.slides[e].swiperLoopMoveDOM = !1 })), w && g.forEach((e => { l.slides[e].swiperLoopMoveDOM = !0, h.append(l.slides[e]), l.slides[e].swiperLoopMoveDOM = !1 })), l.recalcSlides(), "auto" === u.slidesPerView && l.updateSlides(), u.watchSlidesProgress && l.updateSlidesOffset(), s) if (v.length > 0 && y) if (void 0 === t) { const e = l.slidesGrid[b], t = l.slidesGrid[b + E] - e; a ? l.setTranslate(l.translate - t) : (l.slideTo(b + E, 0, !1, !0), n && (l.touches[l.isHorizontal() ? "startX" : "startY"] += t, l.touchEventsData.currentTranslate = l.translate)) } else n && (l.slideToLoop(t, 0, !1, !0), l.touchEventsData.currentTranslate = l.translate); else if (g.length > 0 && w) if (void 0 === t) { const e = l.slidesGrid[b], t = l.slidesGrid[b - S] - e; a ? l.setTranslate(l.translate - t) : (l.slideTo(b - S, 0, !1, !0), n && (l.touches[l.isHorizontal() ? "startX" : "startY"] += t, l.touchEventsData.currentTranslate = l.translate)) } else l.slideToLoop(t, 0, !1, !0); if (l.allowSlidePrev = d, l.allowSlideNext = p, l.controller && l.controller.control && !o) { const e = { slideRealIndex: t, slideTo: !1, direction: i, setTranslate: n, activeSlideIndex: r, byController: !0 }; Array.isArray(l.controller.control) ? l.controller.control.forEach((t => { !t.destroyed && t.params.loop && t.loopFix(e) })) : l.controller.control instanceof l.constructor && l.controller.control.params.loop && l.controller.control.loopFix(e) } l.emit("loopFix") }, loopDestroy: function () { const e = this, { params: t, slidesEl: s } = e; if (!t.loop || e.virtual && e.params.virtual.enabled) return; e.recalcSlides(); const i = []; e.slides.forEach((e => { const t = void 0 === e.swiperSlideIndex ? 1 * e.getAttribute("data-swiper-slide-index") : e.swiperSlideIndex; i[t] = e })), e.slides.forEach((e => { e.removeAttribute("data-swiper-slide-index") })), i.forEach((e => { s.append(e) })), e.recalcSlides(), e.slideTo(e.realIndex, 0) } }; function j(e) { const t = this, s = f(), i = g(), n = t.touchEventsData; n.evCache.push(e); const { params: r, touches: o, enabled: a } = t; if (!a) return; if (!r.simulateTouch && "mouse" === e.pointerType) return; if (t.animating && r.preventInteractionOnTransition) return; !t.animating && r.cssMode && r.loop && t.loopFix(); let l = e; l.originalEvent && (l = l.originalEvent); let c = l.target; if ("wrapper" === r.touchEventsTarget && !t.wrapperEl.contains(c)) return; if ("which" in l && 3 === l.which) return; if ("button" in l && l.button > 0) return; if (n.isTouched && n.isMoved) return; const d = !!r.noSwipingClass && "" !== r.noSwipingClass, p = e.composedPath ? e.composedPath() : e.path; d && l.target && l.target.shadowRoot && p && (c = p[0]); const h = r.noSwipingSelector ? r.noSwipingSelector : `.${r.noSwipingClass}`, u = !(!l.target || !l.target.shadowRoot); if (r.noSwiping && (u ? function (e, t) { return void 0 === t && (t = this), function t(s) { if (!s || s === f() || s === g()) return null; s.assignedSlot && (s = s.assignedSlot); const i = s.closest(e); return i || s.getRootNode ? i || t(s.getRootNode().host) : null }(t) }(h, c) : c.closest(h))) return void (t.allowClick = !0); if (r.swipeHandler && !c.closest(r.swipeHandler)) return; o.currentX = l.pageX, o.currentY = l.pageY; const m = o.currentX, v = o.currentY, b = r.edgeSwipeDetection || r.iOSEdgeSwipeDetection, y = r.edgeSwipeThreshold || r.iOSEdgeSwipeThreshold; if (b && (m <= y || m >= i.innerWidth - y)) { if ("prevent" !== b) return; e.preventDefault() } Object.assign(n, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), o.startX = m, o.startY = v, n.touchStartTime = w(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, r.threshold > 0 && (n.allowThresholdMove = !1); let E = !0; c.matches(n.focusableElements) && (E = !1, "SELECT" === c.nodeName && (n.isTouched = !1)), s.activeElement && s.activeElement.matches(n.focusableElements) && s.activeElement !== c && s.activeElement.blur(); const S = E && t.allowTouchMove && r.touchStartPreventDefault; !r.touchStartForcePreventDefault && !S || c.isContentEditable || l.preventDefault(), r.freeMode && r.freeMode.enabled && t.freeMode && t.animating && !r.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", l) } function Y(e) { const t = f(), s = this, i = s.touchEventsData, { params: n, touches: r, rtlTranslate: o, enabled: a } = s; if (!a) return; if (!n.simulateTouch && "mouse" === e.pointerType) return; let l = e; if (l.originalEvent && (l = l.originalEvent), !i.isTouched) return void (i.startMoving && i.isScrolling && s.emit("touchMoveOpposite", l)); const c = i.evCache.findIndex((e => e.pointerId === l.pointerId)); c >= 0 && (i.evCache[c] = l); const d = i.evCache.length > 1 ? i.evCache[0] : l, p = d.pageX, h = d.pageY; if (l.preventedByNestedSwiper) return r.startX = p, void (r.startY = h); if (!s.allowTouchMove) return l.target.matches(i.focusableElements) || (s.allowClick = !1), void (i.isTouched && (Object.assign(r, { startX: p, startY: h, prevX: s.touches.currentX, prevY: s.touches.currentY, currentX: p, currentY: h }), i.touchStartTime = w())); if (n.touchReleaseOnEdges && !n.loop) if (s.isVertical()) { if (h < r.startY && s.translate <= s.maxTranslate() || h > r.startY && s.translate >= s.minTranslate()) return i.isTouched = !1, void (i.isMoved = !1) } else if (p < r.startX && s.translate <= s.maxTranslate() || p > r.startX && s.translate >= s.minTranslate()) return; if (t.activeElement && l.target === t.activeElement && l.target.matches(i.focusableElements)) return i.isMoved = !0, void (s.allowClick = !1); if (i.allowTouchCallbacks && s.emit("touchMove", l), l.targetTouches && l.targetTouches.length > 1) return; r.currentX = p, r.currentY = h; const u = r.currentX - r.startX, m = r.currentY - r.startY; if (s.params.threshold && Math.sqrt(u ** 2 + m ** 2) < s.params.threshold) return; if (void 0 === i.isScrolling) { let e; s.isHorizontal() && r.currentY === r.startY || s.isVertical() && r.currentX === r.startX ? i.isScrolling = !1 : u * u + m * m >= 25 && (e = 180 * Math.atan2(Math.abs(m), Math.abs(u)) / Math.PI, i.isScrolling = s.isHorizontal() ? e > n.touchAngle : 90 - e > n.touchAngle) } if (i.isScrolling && s.emit("touchMoveOpposite", l), void 0 === i.startMoving && (r.currentX === r.startX && r.currentY === r.startY || (i.startMoving = !0)), i.isScrolling || s.zoom && s.params.zoom && s.params.zoom.enabled && i.evCache.length > 1) return void (i.isTouched = !1); if (!i.startMoving) return; s.allowClick = !1, !n.cssMode && l.cancelable && l.preventDefault(), n.touchMoveStopPropagation && !n.nested && l.stopPropagation(); let v = s.isHorizontal() ? u : m, g = s.isHorizontal() ? r.currentX - r.previousX : r.currentY - r.previousY; n.oneWayMovement && (v = Math.abs(v) * (o ? 1 : -1), g = Math.abs(g) * (o ? 1 : -1)), r.diff = v, v *= n.touchRatio, o && (v = -v, g = -g); const b = s.touchesDirection; s.swipeDirection = v > 0 ? "prev" : "next", s.touchesDirection = g > 0 ? "prev" : "next"; const y = s.params.loop && !n.cssMode; if (!i.isMoved) { if (y && s.loopFix({ direction: s.swipeDirection }), i.startTranslate = s.getTranslate(), s.setTransition(0), s.animating) { const e = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0 }); s.wrapperEl.dispatchEvent(e) } i.allowMomentumBounce = !1, !n.grabCursor || !0 !== s.allowSlideNext && !0 !== s.allowSlidePrev || s.setGrabCursor(!0), s.emit("sliderFirstMove", l) } let E; i.isMoved && b !== s.touchesDirection && y && Math.abs(v) >= 1 && (s.loopFix({ direction: s.swipeDirection, setTranslate: !0 }), E = !0), s.emit("sliderMove", l), i.isMoved = !0, i.currentTranslate = v + i.startTranslate; let S = !0, x = n.resistanceRatio; if (n.touchReleaseOnEdges && (x = 0), v > 0 ? (y && !E && i.currentTranslate > (n.centeredSlides ? s.minTranslate() - s.size / 2 : s.minTranslate()) && s.loopFix({ direction: "prev", setTranslate: !0, activeSlideIndex: 0 }), i.currentTranslate > s.minTranslate() && (S = !1, n.resistance && (i.currentTranslate = s.minTranslate() - 1 + (-s.minTranslate() + i.startTranslate + v) ** x))) : v < 0 && (y && !E && i.currentTranslate < (n.centeredSlides ? s.maxTranslate() + s.size / 2 : s.maxTranslate()) && s.loopFix({ direction: "next", setTranslate: !0, activeSlideIndex: s.slides.length - ("auto" === n.slidesPerView ? s.slidesPerViewDynamic() : Math.ceil(parseFloat(n.slidesPerView, 10))) }), i.currentTranslate < s.maxTranslate() && (S = !1, n.resistance && (i.currentTranslate = s.maxTranslate() + 1 - (s.maxTranslate() - i.startTranslate - v) ** x))), S && (l.preventedByNestedSwiper = !0), !s.allowSlideNext && "next" === s.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !s.allowSlidePrev && "prev" === s.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), s.allowSlidePrev || s.allowSlideNext || (i.currentTranslate = i.startTranslate), n.threshold > 0) { if (!(Math.abs(v) > n.threshold || i.allowThresholdMove)) return void (i.currentTranslate = i.startTranslate); if (!i.allowThresholdMove) return i.allowThresholdMove = !0, r.startX = r.currentX, r.startY = r.currentY, i.currentTranslate = i.startTranslate, void (r.diff = s.isHorizontal() ? r.currentX - r.startX : r.currentY - r.startY) } n.followFinger && !n.cssMode && ((n.freeMode && n.freeMode.enabled && s.freeMode || n.watchSlidesProgress) && (s.updateActiveIndex(), s.updateSlidesClasses()), n.freeMode && n.freeMode.enabled && s.freeMode && s.freeMode.onTouchMove(), s.updateProgress(i.currentTranslate), s.setTranslate(i.currentTranslate)) } function X(e) { const t = this, s = t.touchEventsData, i = s.evCache.findIndex((t => t.pointerId === e.pointerId)); if (i >= 0 && s.evCache.splice(i, 1), ["pointercancel", "pointerout", "pointerleave"].includes(e.type)) { if (!("pointercancel" === e.type && (t.browser.isSafari || t.browser.isWebView))) return } const { params: n, touches: r, rtlTranslate: o, slidesGrid: a, enabled: l } = t; if (!l) return; if (!n.simulateTouch && "mouse" === e.pointerType) return; let c = e; if (c.originalEvent && (c = c.originalEvent), s.allowTouchCallbacks && t.emit("touchEnd", c), s.allowTouchCallbacks = !1, !s.isTouched) return s.isMoved && n.grabCursor && t.setGrabCursor(!1), s.isMoved = !1, void (s.startMoving = !1); n.grabCursor && s.isMoved && s.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1); const d = w(), p = d - s.touchStartTime; if (t.allowClick) { const e = c.path || c.composedPath && c.composedPath(); t.updateClickedSlide(e && e[0] || c.target), t.emit("tap click", c), p < 300 && d - s.lastClickTime < 300 && t.emit("doubleTap doubleClick", c) } if (s.lastClickTime = w(), b((() => { t.destroyed || (t.allowClick = !0) })), !s.isTouched || !s.isMoved || !t.swipeDirection || 0 === r.diff || s.currentTranslate === s.startTranslate) return s.isTouched = !1, s.isMoved = !1, void (s.startMoving = !1); let h; if (s.isTouched = !1, s.isMoved = !1, s.startMoving = !1, h = n.followFinger ? o ? t.translate : -t.translate : -s.currentTranslate, n.cssMode) return; if (n.freeMode && n.freeMode.enabled) return void t.freeMode.onTouchEnd({ currentPos: h }); let u = 0, m = t.slidesSizesGrid[0]; for (let e = 0; e < a.length; e += e < n.slidesPerGroupSkip ? 1 : n.slidesPerGroup) { const t = e < n.slidesPerGroupSkip - 1 ? 1 : n.slidesPerGroup; void 0 !== a[e + t] ? h >= a[e] && h < a[e + t] && (u = e, m = a[e + t] - a[e]) : h >= a[e] && (u = e, m = a[a.length - 1] - a[a.length - 2]) } let f = null, v = null; n.rewind && (t.isBeginning ? v = n.virtual && n.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (f = 0)); const g = (h - a[u]) / m, y = u < n.slidesPerGroupSkip - 1 ? 1 : n.slidesPerGroup; if (p > n.longSwipesMs) { if (!n.longSwipes) return void t.slideTo(t.activeIndex); "next" === t.swipeDirection && (g >= n.longSwipesRatio ? t.slideTo(n.rewind && t.isEnd ? f : u + y) : t.slideTo(u)), "prev" === t.swipeDirection && (g > 1 - n.longSwipesRatio ? t.slideTo(u + y) : null !== v && g < 0 && Math.abs(g) > n.longSwipesRatio ? t.slideTo(v) : t.slideTo(u)) } else { if (!n.shortSwipes) return void t.slideTo(t.activeIndex); t.navigation && (c.target === t.navigation.nextEl || c.target === t.navigation.prevEl) ? c.target === t.navigation.nextEl ? t.slideTo(u + y) : t.slideTo(u) : ("next" === t.swipeDirection && t.slideTo(null !== f ? f : u + y), "prev" === t.swipeDirection && t.slideTo(null !== v ? v : u)) } } function U() { const e = this, { params: t, el: s } = e; if (s && 0 === s.offsetWidth) return; t.breakpoints && e.setBreakpoint(); const { allowSlideNext: i, allowSlidePrev: n, snapGrid: r } = e, o = e.virtual && e.params.virtual.enabled; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(); const a = o && t.loop; !("auto" === t.slidesPerView || t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || a ? e.params.loop && !o ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout), e.autoplay.resizeTimeout = setTimeout((() => { e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume() }), 500)), e.allowSlidePrev = n, e.allowSlideNext = i, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow() } function Z(e) { const t = this; t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation()))) } function K() { const e = this, { wrapperEl: t, rtlTranslate: s, enabled: i } = e; if (!i) return; let n; e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); const r = e.maxTranslate() - e.minTranslate(); n = 0 === r ? 0 : (e.translate - e.minTranslate()) / r, n !== e.progress && e.updateProgress(s ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1) } function Q(e) { const t = this; $(t, e.target), t.params.cssMode || "auto" !== t.params.slidesPerView && !t.params.autoHeight || t.update() } let J = !1; function ee() { } const te = (e, t) => { const s = f(), { params: i, el: n, wrapperEl: r, device: o } = e, a = !!i.nested, l = "on" === t ? "addEventListener" : "removeEventListener", c = t; n[l]("pointerdown", e.onTouchStart, { passive: !1 }), s[l]("pointermove", e.onTouchMove, { passive: !1, capture: a }), s[l]("pointerup", e.onTouchEnd, { passive: !0 }), s[l]("pointercancel", e.onTouchEnd, { passive: !0 }), s[l]("pointerout", e.onTouchEnd, { passive: !0 }), s[l]("pointerleave", e.onTouchEnd, { passive: !0 }), (i.preventClicks || i.preventClicksPropagation) && n[l]("click", e.onClick, !0), i.cssMode && r[l]("scroll", e.onScroll), i.updateOnWindowResize ? e[c](o.ios || o.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", U, !0) : e[c]("observerUpdate", U, !0), n[l]("load", e.onLoad, { capture: !0 }) }; const se = (e, t) => e.grid && t.grid && t.grid.rows > 1; var ie = { init: !0, direction: "horizontal", oneWayMovement: !1, touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 5, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, loop: !1, loopedSlides: null, loopPreventsSliding: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideActiveClass: "swiper-slide-active", slideVisibleClass: "swiper-slide-visible", slideNextClass: "swiper-slide-next", slidePrevClass: "swiper-slide-prev", wrapperClass: "swiper-wrapper", lazyPreloaderClass: "swiper-lazy-preloader", lazyPreloadPrevNext: 0, runCallbacksOnInit: !0, _emitClasses: !1 }; function ne(e, t) { return function (s) { void 0 === s && (s = {}); const i = Object.keys(s)[0], n = s[i]; "object" == typeof n && null !== n ? (["navigation", "pagination", "scrollbar"].indexOf(i) >= 0 && !0 === e[i] && (e[i] = { auto: !0 }), i in e && "enabled" in n ? (!0 === e[i] && (e[i] = { enabled: !0 }), "object" != typeof e[i] || "enabled" in e[i] || (e[i].enabled = !0), e[i] || (e[i] = { enabled: !1 }), S(t, s)) : S(t, s)) : S(t, s) } } const re = { eventsEmitter: N, update: G, translate: q, transition: { setTransition: function (e, t) { const s = this; s.params.cssMode || (s.wrapperEl.style.transitionDuration = `${e}ms`), s.emit("setTransition", e, t) }, transitionStart: function (e, t) { void 0 === e && (e = !0); const s = this, { params: i } = s; i.cssMode || (i.autoHeight && s.updateAutoHeight(), V({ swiper: s, runCallbacks: e, direction: t, step: "Start" })) }, transitionEnd: function (e, t) { void 0 === e && (e = !0); const s = this, { params: i } = s; s.animating = !1, i.cssMode || (s.setTransition(0), V({ swiper: s, runCallbacks: e, direction: t, step: "End" })) } }, slide: F, loop: R, grabCursor: { setGrabCursor: function (e) { const t = this; if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return; const s = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl; t.isElement && (t.__preventObserver__ = !0), s.style.cursor = "move", s.style.cursor = e ? "grabbing" : "grab", t.isElement && requestAnimationFrame((() => { t.__preventObserver__ = !1 })) }, unsetGrabCursor: function () { const e = this; e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0), e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "", e.isElement && requestAnimationFrame((() => { e.__preventObserver__ = !1 }))) } }, events: { attachEvents: function () { const e = this, t = f(), { params: s } = e; e.onTouchStart = j.bind(e), e.onTouchMove = Y.bind(e), e.onTouchEnd = X.bind(e), s.cssMode && (e.onScroll = K.bind(e)), e.onClick = Z.bind(e), e.onLoad = Q.bind(e), J || (t.addEventListener("touchstart", ee), J = !0), te(e, "on") }, detachEvents: function () { te(this, "off") } }, breakpoints: { setBreakpoint: function () { const e = this, { realIndex: t, initialized: s, params: i, el: n } = e, r = i.breakpoints; if (!r || r && 0 === Object.keys(r).length) return; const o = e.getBreakpoint(r, e.params.breakpointsBase, e.el); if (!o || e.currentBreakpoint === o) return; const a = (o in r ? r[o] : void 0) || e.originalParams, l = se(e, i), c = se(e, a), d = i.enabled; l && !c ? (n.classList.remove(`${i.containerModifierClass}grid`, `${i.containerModifierClass}grid-column`), e.emitContainerClasses()) : !l && c && (n.classList.add(`${i.containerModifierClass}grid`), (a.grid.fill && "column" === a.grid.fill || !a.grid.fill && "column" === i.grid.fill) && n.classList.add(`${i.containerModifierClass}grid-column`), e.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach((t => { if (void 0 === a[t]) return; const s = i[t] && i[t].enabled, n = a[t] && a[t].enabled; s && !n && e[t].disable(), !s && n && e[t].enable() })); const p = a.direction && a.direction !== i.direction, h = i.loop && (a.slidesPerView !== i.slidesPerView || p); p && s && e.changeDirection(), S(e.params, a); const u = e.params.enabled; Object.assign(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), d && !u ? e.disable() : !d && u && e.enable(), e.currentBreakpoint = o, e.emit("_beforeBreakpoint", a), h && s && (e.loopDestroy(), e.loopCreate(t), e.updateSlides()), e.emit("breakpoint", a) }, getBreakpoint: function (e, t, s) { if (void 0 === t && (t = "window"), !e || "container" === t && !s) return; let i = !1; const n = g(), r = "window" === t ? n.innerHeight : s.clientHeight, o = Object.keys(e).map((e => { if ("string" == typeof e && 0 === e.indexOf("@")) { const t = parseFloat(e.substr(1)); return { value: r * t, point: e } } return { value: e, point: e } })); o.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10))); for (let e = 0; e < o.length; e += 1) { const { point: r, value: a } = o[e]; "window" === t ? n.matchMedia(`(min-width: ${a}px)`).matches && (i = r) : a <= s.clientWidth && (i = r) } return i || "max" } }, checkOverflow: { checkOverflow: function () { const e = this, { isLocked: t, params: s } = e, { slidesOffsetBefore: i } = s; if (i) { const t = e.slides.length - 1, s = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * i; e.isLocked = e.size > s } else e.isLocked = 1 === e.snapGrid.length; !0 === s.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === s.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock") } }, classes: { addClasses: function () { const e = this, { classNames: t, params: s, rtl: i, el: n, device: r } = e, o = function (e, t) { const s = []; return e.forEach((e => { "object" == typeof e ? Object.keys(e).forEach((i => { e[i] && s.push(t + i) })) : "string" == typeof e && s.push(t + e) })), s }(["initialized", s.direction, { "free-mode": e.params.freeMode && s.freeMode.enabled }, { autoheight: s.autoHeight }, { rtl: i }, { grid: s.grid && s.grid.rows > 1 }, { "grid-column": s.grid && s.grid.rows > 1 && "column" === s.grid.fill }, { android: r.android }, { ios: r.ios }, { "css-mode": s.cssMode }, { centered: s.cssMode && s.centeredSlides }, { "watch-progress": s.watchSlidesProgress }], s.containerModifierClass); t.push(...o), n.classList.add(...t), e.emitContainerClasses() }, removeClasses: function () { const { el: e, classNames: t } = this; e.classList.remove(...t), this.emitContainerClasses() } } }, oe = {}; class ae { constructor() { let e, t; for (var s = arguments.length, i = new Array(s), n = 0; n < s; n++)i[n] = arguments[n]; 1 === i.length && i[0].constructor && "Object" === Object.prototype.toString.call(i[0]).slice(8, -1) ? t = i[0] : [e, t] = i, t || (t = {}), t = S({}, t), e && !t.el && (t.el = e); const r = f(); if (t.el && "string" == typeof t.el && r.querySelectorAll(t.el).length > 1) { const e = []; return r.querySelectorAll(t.el).forEach((s => { const i = S({}, t, { el: s }); e.push(new ae(i)) })), e } const o = this; o.__swiper__ = !0, o.support = z(), o.device = W({ userAgent: t.userAgent }), o.browser = D(), o.eventsListeners = {}, o.eventsAnyListeners = [], o.modules = [...o.__modules__], t.modules && Array.isArray(t.modules) && o.modules.push(...t.modules); const a = {}; o.modules.forEach((e => { e({ params: t, swiper: o, extendParams: ne(t, a), on: o.on.bind(o), once: o.once.bind(o), off: o.off.bind(o), emit: o.emit.bind(o) }) })); const l = S({}, ie, a); return o.params = S({}, l, oe, t), o.originalParams = S({}, o.params), o.passedParams = S({}, t), o.params && o.params.on && Object.keys(o.params.on).forEach((e => { o.on(e, o.params.on[e]) })), o.params && o.params.onAny && o.onAny(o.params.onAny), Object.assign(o, { enabled: o.params.enabled, el: e, classNames: [], slides: [], slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal: () => "horizontal" === o.params.direction, isVertical: () => "vertical" === o.params.direction, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, cssOverflowAdjustment() { return Math.trunc(this.translate / 2 ** 23) * 2 ** 23 }, allowSlideNext: o.params.allowSlideNext, allowSlidePrev: o.params.allowSlidePrev, touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: o.params.focusableElements, lastClickTime: 0, clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, startMoving: void 0, evCache: [] }, allowClick: !0, allowTouchMove: o.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), o.emit("_swiper"), o.params.init && o.init(), o } getSlideIndex(e) { const { slidesEl: t, params: s } = this, i = A(C(t, `.${s.slideClass}, swiper-slide`)[0]); return A(e) - i } getSlideIndexByData(e) { return this.getSlideIndex(this.slides.filter((t => 1 * t.getAttribute("data-swiper-slide-index") === e))[0]) } recalcSlides() { const { slidesEl: e, params: t } = this; this.slides = C(e, `.${t.slideClass}, swiper-slide`) } enable() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable")) } disable() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable")) } setProgress(e, t) { const s = this; e = Math.min(Math.max(e, 0), 1); const i = s.minTranslate(), n = (s.maxTranslate() - i) * e + i; s.translateTo(n, void 0 === t ? 0 : t), s.updateActiveIndex(), s.updateSlidesClasses() } emitContainerClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass))); e.emit("_containerClasses", t.join(" ")) } getSlideClasses(e) { const t = this; return t.destroyed ? "" : e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ") } emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = []; e.slides.forEach((s => { const i = e.getSlideClasses(s); t.push({ slideEl: s, classNames: i }), e.emit("_slideClass", s, i) })), e.emit("_slideClasses", t) } slidesPerViewDynamic(e, t) { void 0 === e && (e = "current"), void 0 === t && (t = !1); const { params: s, slides: i, slidesGrid: n, slidesSizesGrid: r, size: o, activeIndex: a } = this; let l = 1; if (s.centeredSlides) { let e, t = i[a] ? i[a].swiperSlideSize : 0; for (let s = a + 1; s < i.length; s += 1)i[s] && !e && (t += i[s].swiperSlideSize, l += 1, t > o && (e = !0)); for (let s = a - 1; s >= 0; s -= 1)i[s] && !e && (t += i[s].swiperSlideSize, l += 1, t > o && (e = !0)) } else if ("current" === e) for (let e = a + 1; e < i.length; e += 1) { (t ? n[e] + r[e] - n[a] < o : n[e] - n[a] < o) && (l += 1) } else for (let e = a - 1; e >= 0; e -= 1) { n[a] - n[e] < o && (l += 1) } return l } update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: t, params: s } = e; function i() { const t = e.rtlTranslate ? -1 * e.translate : e.translate, s = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate()); e.setTranslate(s), e.updateActiveIndex(), e.updateSlidesClasses() } let n; if (s.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach((t => { t.complete && $(e, t) })), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), s.freeMode && s.freeMode.enabled && !s.cssMode) i(), s.autoHeight && e.updateAutoHeight(); else { if (("auto" === s.slidesPerView || s.slidesPerView > 1) && e.isEnd && !s.centeredSlides) { const t = e.virtual && s.virtual.enabled ? e.virtual.slides : e.slides; n = e.slideTo(t.length - 1, 0, !1, !0) } else n = e.slideTo(e.activeIndex, 0, !1, !0); n || i() } s.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update") } changeDirection(e, t) { void 0 === t && (t = !0); const s = this, i = s.params.direction; return e || (e = "horizontal" === i ? "vertical" : "horizontal"), e === i || "horizontal" !== e && "vertical" !== e || (s.el.classList.remove(`${s.params.containerModifierClass}${i}`), s.el.classList.add(`${s.params.containerModifierClass}${e}`), s.emitContainerClasses(), s.params.direction = e, s.slides.forEach((t => { "vertical" === e ? t.style.width = "" : t.style.height = "" })), s.emit("changeDirection"), t && s.update()), s } changeLanguageDirection(e) { const t = this; t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e, t.rtlTranslate = "horizontal" === t.params.direction && t.rtl, t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update()) } mount(e) { const t = this; if (t.mounted) return !0; let s = e || t.params.el; if ("string" == typeof s && (s = document.querySelector(s)), !s) return !1; s.swiper = t, s.parentNode && s.parentNode.host && "SWIPER-CONTAINER" === s.parentNode.host.nodeName && (t.isElement = !0); const i = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`; let n = (() => { if (s && s.shadowRoot && s.shadowRoot.querySelector) { return s.shadowRoot.querySelector(i()) } return C(s, i())[0] })(); return !n && t.params.createElements && (n = L("div", t.params.wrapperClass), s.append(n), C(s, `.${t.params.slideClass}`).forEach((e => { n.append(e) }))), Object.assign(t, { el: s, wrapperEl: n, slidesEl: t.isElement && !s.parentNode.host.slideSlots ? s.parentNode.host : n, hostEl: t.isElement ? s.parentNode.host : s, mounted: !0, rtl: "rtl" === s.dir.toLowerCase() || "rtl" === O(s, "direction"), rtlTranslate: "horizontal" === t.params.direction && ("rtl" === s.dir.toLowerCase() || "rtl" === O(s, "direction")), wrongRTL: "-webkit-box" === O(n, "display") }), !0 } init(e) { const t = this; if (t.initialized) return t; return !1 === t.mount(e) || (t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents(), [...t.el.querySelectorAll('[loading="lazy"]')].forEach((e => { e.complete ? $(t, e) : e.addEventListener("load", (e => { $(t, e.target) })) })), H(t), t.initialized = !0, H(t), t.emit("init"), t.emit("afterInit")), t } destroy(e, t) { void 0 === e && (e = !0), void 0 === t && (t = !0); const s = this, { params: i, el: n, wrapperEl: r, slides: o } = s; return void 0 === s.params || s.destroyed || (s.emit("beforeDestroy"), s.initialized = !1, s.detachEvents(), i.loop && s.loopDestroy(), t && (s.removeClasses(), n.removeAttribute("style"), r.removeAttribute("style"), o && o.length && o.forEach((e => { e.classList.remove(i.slideVisibleClass, i.slideActiveClass, i.slideNextClass, i.slidePrevClass), e.removeAttribute("style"), e.removeAttribute("data-swiper-slide-index") }))), s.emit("destroy"), Object.keys(s.eventsListeners).forEach((e => { s.off(e) })), !1 !== e && (s.el.swiper = null, function (e) { const t = e; Object.keys(t).forEach((e => { try { t[e] = null } catch (e) { } try { delete t[e] } catch (e) { } })) }(s)), s.destroyed = !0), null } static extendDefaults(e) { S(oe, e) } static get extendedDefaults() { return oe } static get defaults() { return ie } static installModule(e) { ae.prototype.__modules__ || (ae.prototype.__modules__ = []); const t = ae.prototype.__modules__; "function" == typeof e && t.indexOf(e) < 0 && t.push(e) } static use(e) { return Array.isArray(e) ? (e.forEach((e => ae.installModule(e))), ae) : (ae.installModule(e), ae) } } function le(e, t, s, i) { return e.params.createElements && Object.keys(i).forEach((n => { if (!s[n] && !0 === s.auto) { let r = C(e.el, `.${i[n]}`)[0]; r || (r = L("div", i[n]), r.className = i[n], e.el.append(r)), s[n] = r, t[n] = r } })), s } function ce(e) { let { swiper: t, extendParams: s, on: i, emit: n } = e; s({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock", navigationDisabledClass: "swiper-navigation-disabled" } }), t.navigation = { nextEl: null, prevEl: null }; const r = e => (Array.isArray(e) ? e : [e]).filter((e => !!e)); function o(e) { let s; return e && "string" == typeof e && t.isElement && (s = t.el.querySelector(e), s) ? s : (e && ("string" == typeof e && (s = [...document.querySelectorAll(e)]), t.params.uniqueNavElements && "string" == typeof e && s.length > 1 && 1 === t.el.querySelectorAll(e).length && (s = t.el.querySelector(e))), e && !s ? e : s) } function a(e, s) { const i = t.params.navigation; (e = r(e)).forEach((e => { e && (e.classList[s ? "add" : "remove"](...i.disabledClass.split(" ")), "BUTTON" === e.tagName && (e.disabled = s), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](i.lockClass)) })) } function l() { const { nextEl: e, prevEl: s } = t.navigation; if (t.params.loop) return a(s, !1), void a(e, !1); a(s, t.isBeginning && !t.params.rewind), a(e, t.isEnd && !t.params.rewind) } function c(e) { e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(), n("navigationPrev")) } function d(e) { e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(), n("navigationNext")) } function p() { const e = t.params.navigation; if (t.params.navigation = le(t, t.originalParams.navigation, t.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !e.nextEl && !e.prevEl) return; let s = o(e.nextEl), i = o(e.prevEl); Object.assign(t.navigation, { nextEl: s, prevEl: i }), s = r(s), i = r(i); const n = (s, i) => { s && s.addEventListener("click", "next" === i ? d : c), !t.enabled && s && s.classList.add(...e.lockClass.split(" ")) }; s.forEach((e => n(e, "next"))), i.forEach((e => n(e, "prev"))) } function h() { let { nextEl: e, prevEl: s } = t.navigation; e = r(e), s = r(s); const i = (e, s) => { e.removeEventListener("click", "next" === s ? d : c), e.classList.remove(...t.params.navigation.disabledClass.split(" ")) }; e.forEach((e => i(e, "next"))), s.forEach((e => i(e, "prev"))) } i("init", (() => { !1 === t.params.navigation.enabled ? u() : (p(), l()) })), i("toEdge fromEdge lock unlock", (() => { l() })), i("destroy", (() => { h() })), i("enable disable", (() => { let { nextEl: e, prevEl: s } = t.navigation; e = r(e), s = r(s), [...e, ...s].filter((e => !!e)).forEach((e => e.classList[t.enabled ? "remove" : "add"](t.params.navigation.lockClass))) })), i("click", ((e, s) => { let { nextEl: i, prevEl: o } = t.navigation; i = r(i), o = r(o); const a = s.target; if (t.params.navigation.hideOnClick && !o.includes(a) && !i.includes(a)) { if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === a || t.pagination.el.contains(a))) return; let e; i.length ? e = i[0].classList.contains(t.params.navigation.hiddenClass) : o.length && (e = o[0].classList.contains(t.params.navigation.hiddenClass)), n(!0 === e ? "navigationShow" : "navigationHide"), [...i, ...o].filter((e => !!e)).forEach((e => e.classList.toggle(t.params.navigation.hiddenClass))) } })); const u = () => { t.el.classList.add(...t.params.navigation.navigationDisabledClass.split(" ")), h() }; Object.assign(t.navigation, { enable: () => { t.el.classList.remove(...t.params.navigation.navigationDisabledClass.split(" ")), p(), l() }, disable: u, update: l, init: p, destroy: h }) } function de(e) { return void 0 === e && (e = ""), `.${e.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}` } function pe(e) { let { swiper: t, extendParams: s, on: i, emit: n } = e; const r = "swiper-pagination"; let o; s({ pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: e => e, formatFractionTotal: e => e, bulletClass: `${r}-bullet`, bulletActiveClass: `${r}-bullet-active`, modifierClass: `${r}-`, currentClass: `${r}-current`, totalClass: `${r}-total`, hiddenClass: `${r}-hidden`, progressbarFillClass: `${r}-progressbar-fill`, progressbarOppositeClass: `${r}-progressbar-opposite`, clickableClass: `${r}-clickable`, lockClass: `${r}-lock`, horizontalClass: `${r}-horizontal`, verticalClass: `${r}-vertical`, paginationDisabledClass: `${r}-disabled` } }), t.pagination = { el: null, bullets: [] }; let a = 0; const l = e => (Array.isArray(e) ? e : [e]).filter((e => !!e)); function c() { return !t.params.pagination.el || !t.pagination.el || Array.isArray(t.pagination.el) && 0 === t.pagination.el.length } function d(e, s) { const { bulletActiveClass: i } = t.params.pagination; e && (e = e[("prev" === s ? "previous" : "next") + "ElementSibling"]) && (e.classList.add(`${i}-${s}`), (e = e[("prev" === s ? "previous" : "next") + "ElementSibling"]) && e.classList.add(`${i}-${s}-${s}`)) } function p(e) { const s = e.target.closest(de(t.params.pagination.bulletClass)); if (!s) return; e.preventDefault(); const i = A(s) * t.params.slidesPerGroup; if (t.params.loop) { if (t.realIndex === i) return; const e = t.getSlideIndexByData(i), s = t.getSlideIndexByData(t.realIndex); e > t.slides.length - t.loopedSlides && t.loopFix({ direction: e > s ? "next" : "prev", activeSlideIndex: e, slideTo: !1 }), t.slideToLoop(i) } else t.slideTo(i) } function h() { const e = t.rtl, s = t.params.pagination; if (c()) return; let i, r, p = t.pagination.el; p = l(p); const h = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length, u = t.params.loop ? Math.ceil(h / t.params.slidesPerGroup) : t.snapGrid.length; if (t.params.loop ? (r = t.previousRealIndex || 0, i = t.params.slidesPerGroup > 1 ? Math.floor(t.realIndex / t.params.slidesPerGroup) : t.realIndex) : void 0 !== t.snapIndex ? (i = t.snapIndex, r = t.previousSnapIndex) : (r = t.previousIndex || 0, i = t.activeIndex || 0), "bullets" === s.type && t.pagination.bullets && t.pagination.bullets.length > 0) { const n = t.pagination.bullets; let l, c, h; if (s.dynamicBullets && (o = k(n[0], t.isHorizontal() ? "width" : "height", !0), p.forEach((e => { e.style[t.isHorizontal() ? "width" : "height"] = o * (s.dynamicMainBullets + 4) + "px" })), s.dynamicMainBullets > 1 && void 0 !== r && (a += i - (r || 0), a > s.dynamicMainBullets - 1 ? a = s.dynamicMainBullets - 1 : a < 0 && (a = 0)), l = Math.max(i - a, 0), c = l + (Math.min(n.length, s.dynamicMainBullets) - 1), h = (c + l) / 2), n.forEach((e => { const t = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((e => `${s.bulletActiveClass}${e}`))].map((e => "string" == typeof e && e.includes(" ") ? e.split(" ") : e)).flat(); e.classList.remove(...t) })), p.length > 1) n.forEach((e => { const n = A(e); n === i ? e.classList.add(...s.bulletActiveClass.split(" ")) : t.isElement && e.setAttribute("part", "bullet"), s.dynamicBullets && (n >= l && n <= c && e.classList.add(...`${s.bulletActiveClass}-main`.split(" ")), n === l && d(e, "prev"), n === c && d(e, "next")) })); else { const e = n[i]; if (e && e.classList.add(...s.bulletActiveClass.split(" ")), t.isElement && n.forEach(((e, t) => { e.setAttribute("part", t === i ? "bullet-active" : "bullet") })), s.dynamicBullets) { const e = n[l], t = n[c]; for (let e = l; e <= c; e += 1)n[e] && n[e].classList.add(...`${s.bulletActiveClass}-main`.split(" ")); d(e, "prev"), d(t, "next") } } if (s.dynamicBullets) { const i = Math.min(n.length, s.dynamicMainBullets + 4), r = (o * i - o) / 2 - h * o, a = e ? "right" : "left"; n.forEach((e => { e.style[t.isHorizontal() ? a : "top"] = `${r}px` })) } } p.forEach(((e, r) => { if ("fraction" === s.type && (e.querySelectorAll(de(s.currentClass)).forEach((e => { e.textContent = s.formatFractionCurrent(i + 1) })), e.querySelectorAll(de(s.totalClass)).forEach((e => { e.textContent = s.formatFractionTotal(u) }))), "progressbar" === s.type) { let n; n = s.progressbarOpposite ? t.isHorizontal() ? "vertical" : "horizontal" : t.isHorizontal() ? "horizontal" : "vertical"; const r = (i + 1) / u; let o = 1, a = 1; "horizontal" === n ? o = r : a = r, e.querySelectorAll(de(s.progressbarFillClass)).forEach((e => { e.style.transform = `translate3d(0,0,0) scaleX(${o}) scaleY(${a})`, e.style.transitionDuration = `${t.params.speed}ms` })) } "custom" === s.type && s.renderCustom ? (e.innerHTML = s.renderCustom(t, i + 1, u), 0 === r && n("paginationRender", e)) : (0 === r && n("paginationRender", e), n("paginationUpdate", e)), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](s.lockClass) })) } function u() { const e = t.params.pagination; if (c()) return; const s = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length; let i = t.pagination.el; i = l(i); let r = ""; if ("bullets" === e.type) { let i = t.params.loop ? Math.ceil(s / t.params.slidesPerGroup) : t.snapGrid.length; t.params.freeMode && t.params.freeMode.enabled && i > s && (i = s); for (let s = 0; s < i; s += 1)e.renderBullet ? r += e.renderBullet.call(t, s, e.bulletClass) : r += `<${e.bulletElement} ${t.isElement ? 'part="bullet"' : ""} class="${e.bulletClass}"></${e.bulletElement}>` } "fraction" === e.type && (r = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`), "progressbar" === e.type && (r = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`), t.pagination.bullets = [], i.forEach((s => { "custom" !== e.type && (s.innerHTML = r || ""), "bullets" === e.type && t.pagination.bullets.push(...s.querySelectorAll(de(e.bulletClass))) })), "custom" !== e.type && n("paginationRender", i[0]) } function m() { t.params.pagination = le(t, t.originalParams.pagination, t.params.pagination, { el: "swiper-pagination" }); const e = t.params.pagination; if (!e.el) return; let s; "string" == typeof e.el && t.isElement && (s = t.el.querySelector(e.el)), s || "string" != typeof e.el || (s = [...document.querySelectorAll(e.el)]), s || (s = e.el), s && 0 !== s.length && (t.params.uniqueNavElements && "string" == typeof e.el && Array.isArray(s) && s.length > 1 && (s = [...t.el.querySelectorAll(e.el)], s.length > 1 && (s = s.filter((e => M(e, ".swiper")[0] === t.el))[0])), Array.isArray(s) && 1 === s.length && (s = s[0]), Object.assign(t.pagination, { el: s }), s = l(s), s.forEach((s => { "bullets" === e.type && e.clickable && s.classList.add(e.clickableClass), s.classList.add(e.modifierClass + e.type), s.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass), "bullets" === e.type && e.dynamicBullets && (s.classList.add(`${e.modifierClass}${e.type}-dynamic`), a = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), "progressbar" === e.type && e.progressbarOpposite && s.classList.add(e.progressbarOppositeClass), e.clickable && s.addEventListener("click", p), t.enabled || s.classList.add(e.lockClass) }))) } function f() { const e = t.params.pagination; if (c()) return; let s = t.pagination.el; s && (s = l(s), s.forEach((s => { s.classList.remove(e.hiddenClass), s.classList.remove(e.modifierClass + e.type), s.classList.remove(t.isHorizontal() ? e.horizontalClass : e.verticalClass), e.clickable && s.removeEventListener("click", p) }))), t.pagination.bullets && t.pagination.bullets.forEach((t => t.classList.remove(...e.bulletActiveClass.split(" ")))) } i("changeDirection", (() => { if (!t.pagination || !t.pagination.el) return; const e = t.params.pagination; let { el: s } = t.pagination; s = l(s), s.forEach((s => { s.classList.remove(e.horizontalClass, e.verticalClass), s.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass) })) })), i("init", (() => { !1 === t.params.pagination.enabled ? v() : (m(), u(), h()) })), i("activeIndexChange", (() => { void 0 === t.snapIndex && h() })), i("snapIndexChange", (() => { h() })), i("snapGridLengthChange", (() => { u(), h() })), i("destroy", (() => { f() })), i("enable disable", (() => { let { el: e } = t.pagination; e && (e = l(e), e.forEach((e => e.classList[t.enabled ? "remove" : "add"](t.params.pagination.lockClass)))) })), i("lock unlock", (() => { h() })), i("click", ((e, s) => { const i = s.target, r = l(t.pagination.el); if (t.params.pagination.el && t.params.pagination.hideOnClick && r && r.length > 0 && !i.classList.contains(t.params.pagination.bulletClass)) { if (t.navigation && (t.navigation.nextEl && i === t.navigation.nextEl || t.navigation.prevEl && i === t.navigation.prevEl)) return; const e = r[0].classList.contains(t.params.pagination.hiddenClass); n(!0 === e ? "paginationShow" : "paginationHide"), r.forEach((e => e.classList.toggle(t.params.pagination.hiddenClass))) } })); const v = () => { t.el.classList.add(t.params.pagination.paginationDisabledClass); let { el: e } = t.pagination; e && (e = l(e), e.forEach((e => e.classList.add(t.params.pagination.paginationDisabledClass)))), f() }; Object.assign(t.pagination, { enable: () => { t.el.classList.remove(t.params.pagination.paginationDisabledClass); let { el: e } = t.pagination; e && (e = l(e), e.forEach((e => e.classList.remove(t.params.pagination.paginationDisabledClass)))), m(), u(), h() }, disable: v, render: u, update: h, init: m, destroy: f }) } Object.keys(re).forEach((e => { Object.keys(re[e]).forEach((t => { ae.prototype[t] = re[e][t] })) })), ae.use([function (e) { let { swiper: t, on: s, emit: i } = e; const n = g(); let r = null, o = null; const a = () => { t && !t.destroyed && t.initialized && (i("beforeResize"), i("resize")) }, l = () => { t && !t.destroyed && t.initialized && i("orientationchange") }; s("init", (() => { t.params.resizeObserver && void 0 !== n.ResizeObserver ? t && !t.destroyed && t.initialized && (r = new ResizeObserver((e => { o = n.requestAnimationFrame((() => { const { width: s, height: i } = t; let n = s, r = i; e.forEach((e => { let { contentBoxSize: s, contentRect: i, target: o } = e; o && o !== t.el || (n = i ? i.width : (s[0] || s).inlineSize, r = i ? i.height : (s[0] || s).blockSize) })), n === s && r === i || a() })) })), r.observe(t.el)) : (n.addEventListener("resize", a), n.addEventListener("orientationchange", l)) })), s("destroy", (() => { o && n.cancelAnimationFrame(o), r && r.unobserve && t.el && (r.unobserve(t.el), r = null), n.removeEventListener("resize", a), n.removeEventListener("orientationchange", l) })) }, function (e) { let { swiper: t, extendParams: s, on: i, emit: n } = e; const r = [], o = g(), a = function (e, s) { void 0 === s && (s = {}); const i = new (o.MutationObserver || o.WebkitMutationObserver)((e => { if (t.__preventObserver__) return; if (1 === e.length) return void n("observerUpdate", e[0]); const s = function () { n("observerUpdate", e[0]) }; o.requestAnimationFrame ? o.requestAnimationFrame(s) : o.setTimeout(s, 0) })); i.observe(e, { attributes: void 0 === s.attributes || s.attributes, childList: void 0 === s.childList || s.childList, characterData: void 0 === s.characterData || s.characterData }), r.push(i) }; s({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), i("init", (() => { if (t.params.observer) { if (t.params.observeParents) { const e = M(t.hostEl); for (let t = 0; t < e.length; t += 1)a(e[t]) } a(t.hostEl, { childList: t.params.observeSlideChildren }), a(t.wrapperEl, { attributes: !1 }) } })), i("destroy", (() => { r.forEach((e => { e.disconnect() })), r.splice(0, r.length) })) }]), window.addEventListener("load", (function (e) { document.querySelector(".testimonial-page__slider") && new ae(".testimonial-page__slider", { modules: [ce, pe], observer: !0, observeParents: !0, slidesPerView: 2, spaceBetween: 40, speed: 800, pagination: { el: ".swiper-pagination", clickable: !0, type: "fraction", renderFraction: function (e, t) { return '<span class="' + e + '"></span> / <span class="' + t + '"</span>' } }, navigation: { prevEl: ".buttons__arrow.buttons__left", nextEl: ".buttons__arrow.buttons__right" }, breakpoints: { 320: { slidesPerView: 1, spaceBetween: 0, autoHeight: !0 }, 768: { slidesPerView: 1, spaceBetween: 0 }, 992: { slidesPerView: 2, spaceBetween: 40 }, 1268: { slidesPerView: 2, spaceBetween: 40 } }, on: {} }) })); var he = s(807); const ue = function (e) { var t = typeof e; return null != e && ("object" == t || "function" == t) }; const me = "object" == typeof global && global && global.Object === Object && global; var fe = "object" == typeof self && self && self.Object === Object && self; const ve = me || fe || Function("return this")(); const ge = function () { return ve.Date.now() }; var be = /\s/; const we = function (e) { for (var t = e.length; t-- && be.test(e.charAt(t));); return t }; var ye = /^\s+/; const Ee = function (e) { return e ? e.slice(0, we(e) + 1).replace(ye, "") : e }; const Se = ve.Symbol; var xe = Object.prototype, Te = xe.hasOwnProperty, Ce = xe.toString, Le = Se ? Se.toStringTag : void 0; const Oe = function (e) { var t = Te.call(e, Le), s = e[Le]; try { e[Le] = void 0; var i = !0 } catch (e) { } var n = Ce.call(e); return i && (t ? e[Le] = s : delete e[Le]), n }; var Ae = Object.prototype.toString; const Me = function (e) { return Ae.call(e) }; var ke = Se ? Se.toStringTag : void 0; const Pe = function (e) { return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : ke && ke in Object(e) ? Oe(e) : Me(e) }; const _e = function (e) { return null != e && "object" == typeof e }; const Ie = function (e) { return "symbol" == typeof e || _e(e) && "[object Symbol]" == Pe(e) }; var ze = /^[-+]0x[0-9a-f]+$/i, We = /^0b[01]+$/i, De = /^0o[0-7]+$/i, Ne = parseInt; const $e = function (e) { if ("number" == typeof e) return e; if (Ie(e)) return NaN; if (ue(e)) { var t = "function" == typeof e.valueOf ? e.valueOf() : e; e = ue(t) ? t + "" : t } if ("string" != typeof e) return 0 === e ? e : +e; e = Ee(e); var s = We.test(e); return s || De.test(e) ? Ne(e.slice(2), s ? 2 : 8) : ze.test(e) ? NaN : +e }; var Be = Math.max, He = Math.min; const Ge = function (e, t, s) { var i, n, r, o, a, l, c = 0, d = !1, p = !1, h = !0; if ("function" != typeof e) throw new TypeError("Expected a function"); function u(t) { var s = i, r = n; return i = n = void 0, c = t, o = e.apply(r, s) } function m(e) { var s = e - l; return void 0 === l || s >= t || s < 0 || p && e - c >= r } function f() { var e = ge(); if (m(e)) return v(e); a = setTimeout(f, function (e) { var s = t - (e - l); return p ? He(s, r - (e - c)) : s }(e)) } function v(e) { return a = void 0, h && i ? u(e) : (i = n = void 0, o) } function g() { var e = ge(), s = m(e); if (i = arguments, n = this, l = e, s) { if (void 0 === a) return function (e) { return c = e, a = setTimeout(f, t), d ? u(e) : o }(l); if (p) return clearTimeout(a), a = setTimeout(f, t), u(l) } return void 0 === a && (a = setTimeout(f, t)), o } return t = $e(t) || 0, ue(s) && (d = !!s.leading, r = (p = "maxWait" in s) ? Be($e(s.maxWait) || 0, t) : r, h = "trailing" in s ? !!s.trailing : h), g.cancel = function () { void 0 !== a && clearTimeout(a), c = 0, i = l = n = a = void 0 }, g.flush = function () { return void 0 === a ? o : v(ge()) }, g }; const qe = function (e, t, s) { var i = !0, n = !0; if ("function" != typeof e) throw new TypeError("Expected a function"); return ue(s) && (i = "leading" in s ? !!s.leading : i, n = "trailing" in s ? !!s.trailing : n), Ge(e, t, { leading: i, maxWait: t, trailing: n }) }; var Ve = function () { return Ve = Object.assign || function (e) { for (var t, s = 1, i = arguments.length; s < i; s++)for (var n in t = arguments[s]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]); return e }, Ve.apply(this, arguments) }, Fe = null, Re = null; function je() { if (null === Fe) { if ("undefined" == typeof document) return Fe = 0; var e = document.body, t = document.createElement("div"); t.classList.add("simplebar-hide-scrollbar"), e.appendChild(t); var s = t.getBoundingClientRect().right; e.removeChild(t), Fe = s } return Fe } function Ye(e) { return e && e.ownerDocument && e.ownerDocument.defaultView ? e.ownerDocument.defaultView : window } function Xe(e) { return e && e.ownerDocument ? e.ownerDocument : document } he && window.addEventListener("resize", (function () { Re !== window.devicePixelRatio && (Re = window.devicePixelRatio, Fe = null) })); var Ue = function (e) { return Array.prototype.reduce.call(e, (function (e, t) { var s = t.name.match(/data-simplebar-(.+)/); if (s) { var i = s[1].replace(/\W+(.)/g, (function (e, t) { return t.toUpperCase() })); switch (t.value) { case "true": e[i] = !0; break; case "false": e[i] = !1; break; case void 0: e[i] = !0; break; default: e[i] = t.value } } return e }), {}) }; function Ze(e, t) { var s; e && (s = e.classList).add.apply(s, t.split(" ")) } function Ke(e, t) { e && t.split(" ").forEach((function (t) { e.classList.remove(t) })) } function Qe(e) { return ".".concat(e.split(" ").join(".")) } var Je = Object.freeze({ __proto__: null, getElementWindow: Ye, getElementDocument: Xe, getOptions: Ue, addClasses: Ze, removeClasses: Ke, classNamesToQuery: Qe }), et = Ye, tt = Xe, st = Ue, it = Ze, nt = Ke, rt = Qe, ot = function () { function e(t, s) { void 0 === s && (s = {}); var i = this; if (this.removePreventClickId = null, this.minScrollbarWidth = 20, this.stopScrollDelay = 175, this.isScrolling = !1, this.isMouseEntering = !1, this.scrollXTicking = !1, this.scrollYTicking = !1, this.wrapperEl = null, this.contentWrapperEl = null, this.contentEl = null, this.offsetEl = null, this.maskEl = null, this.placeholderEl = null, this.heightAutoObserverWrapperEl = null, this.heightAutoObserverEl = null, this.rtlHelpers = null, this.scrollbarWidth = 0, this.resizeObserver = null, this.mutationObserver = null, this.elStyles = null, this.isRtl = null, this.mouseX = 0, this.mouseY = 0, this.onMouseMove = function () { }, this.onWindowResize = function () { }, this.onStopScrolling = function () { }, this.onMouseEntered = function () { }, this.onScroll = function () { var e = et(i.el); i.scrollXTicking || (e.requestAnimationFrame(i.scrollX), i.scrollXTicking = !0), i.scrollYTicking || (e.requestAnimationFrame(i.scrollY), i.scrollYTicking = !0), i.isScrolling || (i.isScrolling = !0, it(i.el, i.classNames.scrolling)), i.showScrollbar("x"), i.showScrollbar("y"), i.onStopScrolling() }, this.scrollX = function () { i.axis.x.isOverflowing && i.positionScrollbar("x"), i.scrollXTicking = !1 }, this.scrollY = function () { i.axis.y.isOverflowing && i.positionScrollbar("y"), i.scrollYTicking = !1 }, this._onStopScrolling = function () { nt(i.el, i.classNames.scrolling), i.options.autoHide && (i.hideScrollbar("x"), i.hideScrollbar("y")), i.isScrolling = !1 }, this.onMouseEnter = function () { i.isMouseEntering || (it(i.el, i.classNames.mouseEntered), i.showScrollbar("x"), i.showScrollbar("y"), i.isMouseEntering = !0), i.onMouseEntered() }, this._onMouseEntered = function () { nt(i.el, i.classNames.mouseEntered), i.options.autoHide && (i.hideScrollbar("x"), i.hideScrollbar("y")), i.isMouseEntering = !1 }, this._onMouseMove = function (e) { i.mouseX = e.clientX, i.mouseY = e.clientY, (i.axis.x.isOverflowing || i.axis.x.forceVisible) && i.onMouseMoveForAxis("x"), (i.axis.y.isOverflowing || i.axis.y.forceVisible) && i.onMouseMoveForAxis("y") }, this.onMouseLeave = function () { i.onMouseMove.cancel(), (i.axis.x.isOverflowing || i.axis.x.forceVisible) && i.onMouseLeaveForAxis("x"), (i.axis.y.isOverflowing || i.axis.y.forceVisible) && i.onMouseLeaveForAxis("y"), i.mouseX = -1, i.mouseY = -1 }, this._onWindowResize = function () { i.scrollbarWidth = i.getScrollbarWidth(), i.hideNativeScrollbar() }, this.onPointerEvent = function (e) { var t, s; i.axis.x.track.el && i.axis.y.track.el && i.axis.x.scrollbar.el && i.axis.y.scrollbar.el && (i.axis.x.track.rect = i.axis.x.track.el.getBoundingClientRect(), i.axis.y.track.rect = i.axis.y.track.el.getBoundingClientRect(), (i.axis.x.isOverflowing || i.axis.x.forceVisible) && (t = i.isWithinBounds(i.axis.x.track.rect)), (i.axis.y.isOverflowing || i.axis.y.forceVisible) && (s = i.isWithinBounds(i.axis.y.track.rect)), (t || s) && (e.stopPropagation(), "pointerdown" === e.type && "touch" !== e.pointerType && (t && (i.axis.x.scrollbar.rect = i.axis.x.scrollbar.el.getBoundingClientRect(), i.isWithinBounds(i.axis.x.scrollbar.rect) ? i.onDragStart(e, "x") : i.onTrackClick(e, "x")), s && (i.axis.y.scrollbar.rect = i.axis.y.scrollbar.el.getBoundingClientRect(), i.isWithinBounds(i.axis.y.scrollbar.rect) ? i.onDragStart(e, "y") : i.onTrackClick(e, "y"))))) }, this.drag = function (t) { var s, n, r, o, a, l, c, d, p, h, u; if (i.draggedAxis && i.contentWrapperEl) { var m = i.axis[i.draggedAxis].track, f = null !== (n = null === (s = m.rect) || void 0 === s ? void 0 : s[i.axis[i.draggedAxis].sizeAttr]) && void 0 !== n ? n : 0, v = i.axis[i.draggedAxis].scrollbar, g = null !== (o = null === (r = i.contentWrapperEl) || void 0 === r ? void 0 : r[i.axis[i.draggedAxis].scrollSizeAttr]) && void 0 !== o ? o : 0, b = parseInt(null !== (l = null === (a = i.elStyles) || void 0 === a ? void 0 : a[i.axis[i.draggedAxis].sizeAttr]) && void 0 !== l ? l : "0px", 10); t.preventDefault(), t.stopPropagation(); var w = ("y" === i.draggedAxis ? t.pageY : t.pageX) - (null !== (d = null === (c = m.rect) || void 0 === c ? void 0 : c[i.axis[i.draggedAxis].offsetAttr]) && void 0 !== d ? d : 0) - i.axis[i.draggedAxis].dragOffset, y = (w = "x" === i.draggedAxis && i.isRtl ? (null !== (h = null === (p = m.rect) || void 0 === p ? void 0 : p[i.axis[i.draggedAxis].sizeAttr]) && void 0 !== h ? h : 0) - v.size - w : w) / (f - v.size) * (g - b); "x" === i.draggedAxis && i.isRtl && (y = (null === (u = e.getRtlHelpers()) || void 0 === u ? void 0 : u.isScrollingToNegative) ? -y : y), i.contentWrapperEl[i.axis[i.draggedAxis].scrollOffsetAttr] = y } }, this.onEndDrag = function (e) { var t = tt(i.el), s = et(i.el); e.preventDefault(), e.stopPropagation(), nt(i.el, i.classNames.dragging), t.removeEventListener("mousemove", i.drag, !0), t.removeEventListener("mouseup", i.onEndDrag, !0), i.removePreventClickId = s.setTimeout((function () { t.removeEventListener("click", i.preventClick, !0), t.removeEventListener("dblclick", i.preventClick, !0), i.removePreventClickId = null })) }, this.preventClick = function (e) { e.preventDefault(), e.stopPropagation() }, this.el = t, this.options = Ve(Ve({}, e.defaultOptions), s), this.classNames = Ve(Ve({}, e.defaultOptions.classNames), s.classNames), this.axis = { x: { scrollOffsetAttr: "scrollLeft", sizeAttr: "width", scrollSizeAttr: "scrollWidth", offsetSizeAttr: "offsetWidth", offsetAttr: "left", overflowAttr: "overflowX", dragOffset: 0, isOverflowing: !0, forceVisible: !1, track: { size: null, el: null, rect: null, isVisible: !1 }, scrollbar: { size: null, el: null, rect: null, isVisible: !1 } }, y: { scrollOffsetAttr: "scrollTop", sizeAttr: "height", scrollSizeAttr: "scrollHeight", offsetSizeAttr: "offsetHeight", offsetAttr: "top", overflowAttr: "overflowY", dragOffset: 0, isOverflowing: !0, forceVisible: !1, track: { size: null, el: null, rect: null, isVisible: !1 }, scrollbar: { size: null, el: null, rect: null, isVisible: !1 } } }, "object" != typeof this.el || !this.el.nodeName) throw new Error("Argument passed to SimpleBar must be an HTML element instead of ".concat(this.el)); this.onMouseMove = qe(this._onMouseMove, 64), this.onWindowResize = Ge(this._onWindowResize, 64, { leading: !0 }), this.onStopScrolling = Ge(this._onStopScrolling, this.stopScrollDelay), this.onMouseEntered = Ge(this._onMouseEntered, this.stopScrollDelay), this.init() } return e.getRtlHelpers = function () { if (e.rtlHelpers) return e.rtlHelpers; var t = document.createElement("div"); t.innerHTML = '<div class="simplebar-dummy-scrollbar-size"><div></div></div>'; var s = t.firstElementChild, i = null == s ? void 0 : s.firstElementChild; if (!i) return null; document.body.appendChild(s), s.scrollLeft = 0; var n = e.getOffset(s), r = e.getOffset(i); s.scrollLeft = -999; var o = e.getOffset(i); return document.body.removeChild(s), e.rtlHelpers = { isScrollOriginAtZero: n.left !== r.left, isScrollingToNegative: r.left !== o.left }, e.rtlHelpers }, e.prototype.getScrollbarWidth = function () { try { return this.contentWrapperEl && "none" === getComputedStyle(this.contentWrapperEl, "::-webkit-scrollbar").display || "scrollbarWidth" in document.documentElement.style || "-ms-overflow-style" in document.documentElement.style ? 0 : je() } catch (e) { return je() } }, e.getOffset = function (e) { var t = e.getBoundingClientRect(), s = tt(e), i = et(e); return { top: t.top + (i.pageYOffset || s.documentElement.scrollTop), left: t.left + (i.pageXOffset || s.documentElement.scrollLeft) } }, e.prototype.init = function () { he && (this.initDOM(), this.rtlHelpers = e.getRtlHelpers(), this.scrollbarWidth = this.getScrollbarWidth(), this.recalculate(), this.initListeners()) }, e.prototype.initDOM = function () { var e, t; this.wrapperEl = this.el.querySelector(rt(this.classNames.wrapper)), this.contentWrapperEl = this.options.scrollableNode || this.el.querySelector(rt(this.classNames.contentWrapper)), this.contentEl = this.options.contentNode || this.el.querySelector(rt(this.classNames.contentEl)), this.offsetEl = this.el.querySelector(rt(this.classNames.offset)), this.maskEl = this.el.querySelector(rt(this.classNames.mask)), this.placeholderEl = this.findChild(this.wrapperEl, rt(this.classNames.placeholder)), this.heightAutoObserverWrapperEl = this.el.querySelector(rt(this.classNames.heightAutoObserverWrapperEl)), this.heightAutoObserverEl = this.el.querySelector(rt(this.classNames.heightAutoObserverEl)), this.axis.x.track.el = this.findChild(this.el, "".concat(rt(this.classNames.track)).concat(rt(this.classNames.horizontal))), this.axis.y.track.el = this.findChild(this.el, "".concat(rt(this.classNames.track)).concat(rt(this.classNames.vertical))), this.axis.x.scrollbar.el = (null === (e = this.axis.x.track.el) || void 0 === e ? void 0 : e.querySelector(rt(this.classNames.scrollbar))) || null, this.axis.y.scrollbar.el = (null === (t = this.axis.y.track.el) || void 0 === t ? void 0 : t.querySelector(rt(this.classNames.scrollbar))) || null, this.options.autoHide || (it(this.axis.x.scrollbar.el, this.classNames.visible), it(this.axis.y.scrollbar.el, this.classNames.visible)) }, e.prototype.initListeners = function () { var e, t = this, s = et(this.el); if (this.el.addEventListener("mouseenter", this.onMouseEnter), this.el.addEventListener("pointerdown", this.onPointerEvent, !0), this.el.addEventListener("mousemove", this.onMouseMove), this.el.addEventListener("mouseleave", this.onMouseLeave), null === (e = this.contentWrapperEl) || void 0 === e || e.addEventListener("scroll", this.onScroll), s.addEventListener("resize", this.onWindowResize), this.contentEl) { if (window.ResizeObserver) { var i = !1, n = s.ResizeObserver || ResizeObserver; this.resizeObserver = new n((function () { i && s.requestAnimationFrame((function () { t.recalculate() })) })), this.resizeObserver.observe(this.el), this.resizeObserver.observe(this.contentEl), s.requestAnimationFrame((function () { i = !0 })) } this.mutationObserver = new s.MutationObserver((function () { s.requestAnimationFrame((function () { t.recalculate() })) })), this.mutationObserver.observe(this.contentEl, { childList: !0, subtree: !0, characterData: !0 }) } }, e.prototype.recalculate = function () { if (this.heightAutoObserverEl && this.contentEl && this.contentWrapperEl && this.wrapperEl && this.placeholderEl) { var e = et(this.el); this.elStyles = e.getComputedStyle(this.el), this.isRtl = "rtl" === this.elStyles.direction; var t = this.contentEl.offsetWidth, s = this.heightAutoObserverEl.offsetHeight <= 1, i = this.heightAutoObserverEl.offsetWidth <= 1 || t > 0, n = this.contentWrapperEl.offsetWidth, r = this.elStyles.overflowX, o = this.elStyles.overflowY; this.contentEl.style.padding = "".concat(this.elStyles.paddingTop, " ").concat(this.elStyles.paddingRight, " ").concat(this.elStyles.paddingBottom, " ").concat(this.elStyles.paddingLeft), this.wrapperEl.style.margin = "-".concat(this.elStyles.paddingTop, " -").concat(this.elStyles.paddingRight, " -").concat(this.elStyles.paddingBottom, " -").concat(this.elStyles.paddingLeft); var a = this.contentEl.scrollHeight, l = this.contentEl.scrollWidth; this.contentWrapperEl.style.height = s ? "auto" : "100%", this.placeholderEl.style.width = i ? "".concat(t || l, "px") : "auto", this.placeholderEl.style.height = "".concat(a, "px"); var c = this.contentWrapperEl.offsetHeight; this.axis.x.isOverflowing = 0 !== t && l > t, this.axis.y.isOverflowing = a > c, this.axis.x.isOverflowing = "hidden" !== r && this.axis.x.isOverflowing, this.axis.y.isOverflowing = "hidden" !== o && this.axis.y.isOverflowing, this.axis.x.forceVisible = "x" === this.options.forceVisible || !0 === this.options.forceVisible, this.axis.y.forceVisible = "y" === this.options.forceVisible || !0 === this.options.forceVisible, this.hideNativeScrollbar(); var d = this.axis.x.isOverflowing ? this.scrollbarWidth : 0, p = this.axis.y.isOverflowing ? this.scrollbarWidth : 0; this.axis.x.isOverflowing = this.axis.x.isOverflowing && l > n - p, this.axis.y.isOverflowing = this.axis.y.isOverflowing && a > c - d, this.axis.x.scrollbar.size = this.getScrollbarSize("x"), this.axis.y.scrollbar.size = this.getScrollbarSize("y"), this.axis.x.scrollbar.el && (this.axis.x.scrollbar.el.style.width = "".concat(this.axis.x.scrollbar.size, "px")), this.axis.y.scrollbar.el && (this.axis.y.scrollbar.el.style.height = "".concat(this.axis.y.scrollbar.size, "px")), this.positionScrollbar("x"), this.positionScrollbar("y"), this.toggleTrackVisibility("x"), this.toggleTrackVisibility("y") } }, e.prototype.getScrollbarSize = function (e) { var t, s; if (void 0 === e && (e = "y"), !this.axis[e].isOverflowing || !this.contentEl) return 0; var i, n = this.contentEl[this.axis[e].scrollSizeAttr], r = null !== (s = null === (t = this.axis[e].track.el) || void 0 === t ? void 0 : t[this.axis[e].offsetSizeAttr]) && void 0 !== s ? s : 0, o = r / n; return i = Math.max(~~(o * r), this.options.scrollbarMinSize), this.options.scrollbarMaxSize && (i = Math.min(i, this.options.scrollbarMaxSize)), i }, e.prototype.positionScrollbar = function (t) { var s, i, n; void 0 === t && (t = "y"); var r = this.axis[t].scrollbar; if (this.axis[t].isOverflowing && this.contentWrapperEl && r.el && this.elStyles) { var o = this.contentWrapperEl[this.axis[t].scrollSizeAttr], a = (null === (s = this.axis[t].track.el) || void 0 === s ? void 0 : s[this.axis[t].offsetSizeAttr]) || 0, l = parseInt(this.elStyles[this.axis[t].sizeAttr], 10), c = this.contentWrapperEl[this.axis[t].scrollOffsetAttr]; c = "x" === t && this.isRtl && (null === (i = e.getRtlHelpers()) || void 0 === i ? void 0 : i.isScrollOriginAtZero) ? -c : c, "x" === t && this.isRtl && (c = (null === (n = e.getRtlHelpers()) || void 0 === n ? void 0 : n.isScrollingToNegative) ? c : -c); var d = c / (o - l), p = ~~((a - r.size) * d); p = "x" === t && this.isRtl ? -p + (a - r.size) : p, r.el.style.transform = "x" === t ? "translate3d(".concat(p, "px, 0, 0)") : "translate3d(0, ".concat(p, "px, 0)") } }, e.prototype.toggleTrackVisibility = function (e) { void 0 === e && (e = "y"); var t = this.axis[e].track.el, s = this.axis[e].scrollbar.el; t && s && this.contentWrapperEl && (this.axis[e].isOverflowing || this.axis[e].forceVisible ? (t.style.visibility = "visible", this.contentWrapperEl.style[this.axis[e].overflowAttr] = "scroll", this.el.classList.add("".concat(this.classNames.scrollable, "-").concat(e))) : (t.style.visibility = "hidden", this.contentWrapperEl.style[this.axis[e].overflowAttr] = "hidden", this.el.classList.remove("".concat(this.classNames.scrollable, "-").concat(e))), this.axis[e].isOverflowing ? s.style.display = "block" : s.style.display = "none") }, e.prototype.showScrollbar = function (e) { void 0 === e && (e = "y"), this.axis[e].isOverflowing && !this.axis[e].scrollbar.isVisible && (it(this.axis[e].scrollbar.el, this.classNames.visible), this.axis[e].scrollbar.isVisible = !0) }, e.prototype.hideScrollbar = function (e) { void 0 === e && (e = "y"), this.axis[e].isOverflowing && this.axis[e].scrollbar.isVisible && (nt(this.axis[e].scrollbar.el, this.classNames.visible), this.axis[e].scrollbar.isVisible = !1) }, e.prototype.hideNativeScrollbar = function () { this.offsetEl && (this.offsetEl.style[this.isRtl ? "left" : "right"] = this.axis.y.isOverflowing || this.axis.y.forceVisible ? "-".concat(this.scrollbarWidth, "px") : "0px", this.offsetEl.style.bottom = this.axis.x.isOverflowing || this.axis.x.forceVisible ? "-".concat(this.scrollbarWidth, "px") : "0px") }, e.prototype.onMouseMoveForAxis = function (e) { void 0 === e && (e = "y"); var t = this.axis[e]; t.track.el && t.scrollbar.el && (t.track.rect = t.track.el.getBoundingClientRect(), t.scrollbar.rect = t.scrollbar.el.getBoundingClientRect(), this.isWithinBounds(t.track.rect) ? (this.showScrollbar(e), it(t.track.el, this.classNames.hover), this.isWithinBounds(t.scrollbar.rect) ? it(t.scrollbar.el, this.classNames.hover) : nt(t.scrollbar.el, this.classNames.hover)) : (nt(t.track.el, this.classNames.hover), this.options.autoHide && this.hideScrollbar(e))) }, e.prototype.onMouseLeaveForAxis = function (e) { void 0 === e && (e = "y"), nt(this.axis[e].track.el, this.classNames.hover), nt(this.axis[e].scrollbar.el, this.classNames.hover), this.options.autoHide && this.hideScrollbar(e) }, e.prototype.onDragStart = function (e, t) { var s; void 0 === t && (t = "y"); var i = tt(this.el), n = et(this.el), r = this.axis[t].scrollbar, o = "y" === t ? e.pageY : e.pageX; this.axis[t].dragOffset = o - ((null === (s = r.rect) || void 0 === s ? void 0 : s[this.axis[t].offsetAttr]) || 0), this.draggedAxis = t, it(this.el, this.classNames.dragging), i.addEventListener("mousemove", this.drag, !0), i.addEventListener("mouseup", this.onEndDrag, !0), null === this.removePreventClickId ? (i.addEventListener("click", this.preventClick, !0), i.addEventListener("dblclick", this.preventClick, !0)) : (n.clearTimeout(this.removePreventClickId), this.removePreventClickId = null) }, e.prototype.onTrackClick = function (e, t) { var s, i, n, r, o = this; void 0 === t && (t = "y"); var a = this.axis[t]; if (this.options.clickOnTrack && a.scrollbar.el && this.contentWrapperEl) { e.preventDefault(); var l = et(this.el); this.axis[t].scrollbar.rect = a.scrollbar.el.getBoundingClientRect(); var c = null !== (i = null === (s = this.axis[t].scrollbar.rect) || void 0 === s ? void 0 : s[this.axis[t].offsetAttr]) && void 0 !== i ? i : 0, d = parseInt(null !== (r = null === (n = this.elStyles) || void 0 === n ? void 0 : n[this.axis[t].sizeAttr]) && void 0 !== r ? r : "0px", 10), p = this.contentWrapperEl[this.axis[t].scrollOffsetAttr], h = ("y" === t ? this.mouseY - c : this.mouseX - c) < 0 ? -1 : 1, u = -1 === h ? p - d : p + d, m = function () { o.contentWrapperEl && (-1 === h ? p > u && (p -= 40, o.contentWrapperEl[o.axis[t].scrollOffsetAttr] = p, l.requestAnimationFrame(m)) : p < u && (p += 40, o.contentWrapperEl[o.axis[t].scrollOffsetAttr] = p, l.requestAnimationFrame(m))) }; m() } }, e.prototype.getContentElement = function () { return this.contentEl }, e.prototype.getScrollElement = function () { return this.contentWrapperEl }, e.prototype.removeListeners = function () { var e = et(this.el); this.el.removeEventListener("mouseenter", this.onMouseEnter), this.el.removeEventListener("pointerdown", this.onPointerEvent, !0), this.el.removeEventListener("mousemove", this.onMouseMove), this.el.removeEventListener("mouseleave", this.onMouseLeave), this.contentWrapperEl && this.contentWrapperEl.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onWindowResize), this.mutationObserver && this.mutationObserver.disconnect(), this.resizeObserver && this.resizeObserver.disconnect(), this.onMouseMove.cancel(), this.onWindowResize.cancel(), this.onStopScrolling.cancel(), this.onMouseEntered.cancel() }, e.prototype.unMount = function () { this.removeListeners() }, e.prototype.isWithinBounds = function (e) { return this.mouseX >= e.left && this.mouseX <= e.left + e.width && this.mouseY >= e.top && this.mouseY <= e.top + e.height }, e.prototype.findChild = function (e, t) { var s = e.matches || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector; return Array.prototype.filter.call(e.children, (function (e) { return s.call(e, t) }))[0] }, e.rtlHelpers = null, e.defaultOptions = { forceVisible: !1, clickOnTrack: !0, scrollbarMinSize: 25, scrollbarMaxSize: 0, ariaLabel: "scrollable content", classNames: { contentEl: "simplebar-content", contentWrapper: "simplebar-content-wrapper", offset: "simplebar-offset", mask: "simplebar-mask", wrapper: "simplebar-wrapper", placeholder: "simplebar-placeholder", scrollbar: "simplebar-scrollbar", track: "simplebar-track", heightAutoObserverWrapperEl: "simplebar-height-auto-observer-wrapper", heightAutoObserverEl: "simplebar-height-auto-observer", visible: "simplebar-visible", horizontal: "simplebar-horizontal", vertical: "simplebar-vertical", hover: "simplebar-hover", dragging: "simplebar-dragging", scrolling: "simplebar-scrolling", scrollable: "simplebar-scrollable", mouseEntered: "simplebar-mouse-entered" }, scrollableNode: null, contentNode: null, autoHide: !0 }, e.getOptions = st, e.helpers = Je, e }(), at = function (e, t) { return at = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]) }, at(e, t) }; var lt = ot.helpers, ct = lt.getOptions, dt = lt.addClasses, pt = function (e) { function t() { for (var s = [], i = 0; i < arguments.length; i++)s[i] = arguments[i]; var n = e.apply(this, s) || this; return t.instances.set(s[0], n), n } return function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); function s() { this.constructor = e } at(e, t), e.prototype = null === t ? Object.create(t) : (s.prototype = t.prototype, new s) }(t, e), t.initDOMLoadedElements = function () { document.removeEventListener("DOMContentLoaded", this.initDOMLoadedElements), window.removeEventListener("load", this.initDOMLoadedElements), Array.prototype.forEach.call(document.querySelectorAll("[data-simplebar]"), (function (e) { "init" === e.getAttribute("data-simplebar") || t.instances.has(e) || new t(e, ct(e.attributes)) })) }, t.removeObserver = function () { var e; null === (e = t.globalObserver) || void 0 === e || e.disconnect() }, t.prototype.initDOM = function () { var e, t, s, i = this; if (!Array.prototype.filter.call(this.el.children, (function (e) { return e.classList.contains(i.classNames.wrapper) })).length) { for (this.wrapperEl = document.createElement("div"), this.contentWrapperEl = document.createElement("div"), this.offsetEl = document.createElement("div"), this.maskEl = document.createElement("div"), this.contentEl = document.createElement("div"), this.placeholderEl = document.createElement("div"), this.heightAutoObserverWrapperEl = document.createElement("div"), this.heightAutoObserverEl = document.createElement("div"), dt(this.wrapperEl, this.classNames.wrapper), dt(this.contentWrapperEl, this.classNames.contentWrapper), dt(this.offsetEl, this.classNames.offset), dt(this.maskEl, this.classNames.mask), dt(this.contentEl, this.classNames.contentEl), dt(this.placeholderEl, this.classNames.placeholder), dt(this.heightAutoObserverWrapperEl, this.classNames.heightAutoObserverWrapperEl), dt(this.heightAutoObserverEl, this.classNames.heightAutoObserverEl); this.el.firstChild;)this.contentEl.appendChild(this.el.firstChild); this.contentWrapperEl.appendChild(this.contentEl), this.offsetEl.appendChild(this.contentWrapperEl), this.maskEl.appendChild(this.offsetEl), this.heightAutoObserverWrapperEl.appendChild(this.heightAutoObserverEl), this.wrapperEl.appendChild(this.heightAutoObserverWrapperEl), this.wrapperEl.appendChild(this.maskEl), this.wrapperEl.appendChild(this.placeholderEl), this.el.appendChild(this.wrapperEl), null === (e = this.contentWrapperEl) || void 0 === e || e.setAttribute("tabindex", "0"), null === (t = this.contentWrapperEl) || void 0 === t || t.setAttribute("role", "region"), null === (s = this.contentWrapperEl) || void 0 === s || s.setAttribute("aria-label", this.options.ariaLabel) } if (!this.axis.x.track.el || !this.axis.y.track.el) { var n = document.createElement("div"), r = document.createElement("div"); dt(n, this.classNames.track), dt(r, this.classNames.scrollbar), n.appendChild(r), this.axis.x.track.el = n.cloneNode(!0), dt(this.axis.x.track.el, this.classNames.horizontal), this.axis.y.track.el = n.cloneNode(!0), dt(this.axis.y.track.el, this.classNames.vertical), this.el.appendChild(this.axis.x.track.el), this.el.appendChild(this.axis.y.track.el) } ot.prototype.initDOM.call(this), this.el.setAttribute("data-simplebar", "init") }, t.prototype.unMount = function () { ot.prototype.unMount.call(this), t.instances.delete(this.el) }, t.initHtmlApi = function () { this.initDOMLoadedElements = this.initDOMLoadedElements.bind(this), "undefined" != typeof MutationObserver && (this.globalObserver = new MutationObserver(t.handleMutations), this.globalObserver.observe(document, { childList: !0, subtree: !0 })), "complete" === document.readyState || "loading" !== document.readyState && !document.documentElement.doScroll ? window.setTimeout(this.initDOMLoadedElements) : (document.addEventListener("DOMContentLoaded", this.initDOMLoadedElements), window.addEventListener("load", this.initDOMLoadedElements)) }, t.handleMutations = function (e) { e.forEach((function (e) { e.addedNodes.forEach((function (e) { 1 === e.nodeType && (e.hasAttribute("data-simplebar") ? !t.instances.has(e) && document.documentElement.contains(e) && new t(e, ct(e.attributes)) : e.querySelectorAll("[data-simplebar]").forEach((function (e) { "init" !== e.getAttribute("data-simplebar") && !t.instances.has(e) && document.documentElement.contains(e) && new t(e, ct(e.attributes)) }))) })), e.removedNodes.forEach((function (e) { 1 === e.nodeType && ("init" === e.getAttribute("data-simplebar") ? t.instances.has(e) && !document.documentElement.contains(e) && t.instances.get(e).unMount() : Array.prototype.forEach.call(e.querySelectorAll('[data-simplebar="init"]'), (function (e) { t.instances.has(e) && !document.documentElement.contains(e) && t.instances.get(e).unMount() }))) })) })) }, t.instances = new WeakMap, t }(ot); he && pt.initHtmlApi(); e.watcher = new class { constructor(e) { this.config = Object.assign({ logging: !0 }, e), this.observer, !document.documentElement.classList.contains("watcher") && this.scrollWatcherRun() } scrollWatcherUpdate() { this.scrollWatcherRun() } scrollWatcherRun() { document.documentElement.classList.add("watcher"), this.scrollWatcherConstructor(document.querySelectorAll("[data-watch]")) } scrollWatcherConstructor(e) { if (e.length) { this.scrollWatcherLogging(`Прокинувся, стежу за об'єктами (${e.length})...`), c(Array.from(e).map((function (e) { return `${e.dataset.watchRoot ? e.dataset.watchRoot : null}|${e.dataset.watchMargin ? e.dataset.watchMargin : "0px"}|${e.dataset.watchThreshold ? e.dataset.watchThreshold : 0}` }))).forEach((t => { let s = t.split("|"), i = { root: s[0], margin: s[1], threshold: s[2] }, n = Array.from(e).filter((function (e) { let t = e.dataset.watchRoot ? e.dataset.watchRoot : null, s = e.dataset.watchMargin ? e.dataset.watchMargin : "0px", n = e.dataset.watchThreshold ? e.dataset.watchThreshold : 0; if (String(t) === i.root && String(s) === i.margin && String(n) === i.threshold) return e })), r = this.getScrollWatcherConfig(i); this.scrollWatcherInit(n, r) })) } else this.scrollWatcherLogging("Сплю, немає об'єктів для стеження. ZzzZZzz") } getScrollWatcherConfig(e) { let t = {}; if (document.querySelector(e.root) ? t.root = document.querySelector(e.root) : "null" !== e.root && this.scrollWatcherLogging(`Эмм... батьківського об'єкта ${e.root} немає на сторінці`), t.rootMargin = e.margin, !(e.margin.indexOf("px") < 0 && e.margin.indexOf("%") < 0)) { if ("prx" === e.threshold) { e.threshold = []; for (let t = 0; t <= 1; t += .005)e.threshold.push(t) } else e.threshold = e.threshold.split(","); return t.threshold = e.threshold, t } this.scrollWatcherLogging("йой, налаштування data-watch-margin потрібно задавати в PX або %") } scrollWatcherCreate(e) { this.observer = new IntersectionObserver(((e, t) => { e.forEach((e => { this.scrollWatcherCallback(e, t) })) }), e) } scrollWatcherInit(e, t) { this.scrollWatcherCreate(t), e.forEach((e => this.observer.observe(e))) } scrollWatcherIntersecting(e, t) { e.isIntersecting ? (!t.classList.contains("_watcher-view") && t.classList.add("_watcher-view"), this.scrollWatcherLogging(`Я бачу ${t.classList}, додав клас _watcher-view`)) : (t.classList.contains("_watcher-view") && t.classList.remove("_watcher-view"), this.scrollWatcherLogging(`Я не бачу ${t.classList}, прибрав клас _watcher-view`)) } scrollWatcherOff(e, t) { t.unobserve(e), this.scrollWatcherLogging(`Я перестав стежити за ${e.classList}`) } scrollWatcherLogging(e) { this.config.logging && l(`[Спостерігач]: ${e}`) } scrollWatcherCallback(e, t) { const s = e.target; this.scrollWatcherIntersecting(e, s), s.hasAttribute("data-watch-once") && e.isIntersecting && this.scrollWatcherOff(s, t), document.dispatchEvent(new CustomEvent("watcherCallback", { detail: { entry: e } })) } }({}); class ht { constructor(e, t) { let s = { noEventSelector: "[data-no-event]", classInit: "fp-init", wrapperAnimatedClass: "fp-switching", selectorSection: "[data-fp-section]", activeClass: "active-section", previousClass: "previous-section", nextClass: "next-section", idActiveSection: 0, mode: e.dataset.fpEffect ? e.dataset.fpEffect : "slider", bullets: !!e.hasAttribute("data-fp-bullets"), bulletsClass: "fp-bullets", bulletClass: "fp-bullet", bulletActiveClass: "fp-bullet-active", onInit: function () { }, onSwitching: function () { }, onDestroy: function () { } }; this.options = Object.assign(s, t), this.wrapper = e, this.sections = this.wrapper.querySelectorAll(this.options.selectorSection), this.activeSection = !1, this.activeSectionId = !1, this.previousSection = !1, this.previousSectionId = !1, this.nextSection = !1, this.nextSectionId = !1, this.bulletsWrapper = !1, this.stopEvent = !1, this.sections.length && this.init() } init() { this.options.idActiveSection > this.sections.length - 1 || (this.setId(), this.activeSectionId = this.options.idActiveSection, this.setEffectsClasses(), this.setClasses(), this.setStyle(), this.options.bullets && (this.setBullets(), this.setActiveBullet(this.activeSectionId)), this.events(), setTimeout((() => { document.documentElement.classList.add(this.options.classInit), this.options.onInit(this), document.dispatchEvent(new CustomEvent("fpinit", { detail: { fp: this } })) }), 0)) } destroy() { this.removeEvents(), this.removeClasses(), document.documentElement.classList.remove(this.options.classInit), this.wrapper.classList.remove(this.options.wrapperAnimatedClass), this.removeEffectsClasses(), this.removeZIndex(), this.removeStyle(), this.removeId(), this.options.onDestroy(this), document.dispatchEvent(new CustomEvent("fpdestroy", { detail: { fp: this } })) } setId() { for (let e = 0; e < this.sections.length; e++) { this.sections[e].setAttribute("data-fp-id", e) } } removeId() { for (let e = 0; e < this.sections.length; e++) { this.sections[e].removeAttribute("data-fp-id") } } setClasses() { this.previousSectionId = this.activeSectionId - 1 >= 0 && this.activeSectionId - 1, this.nextSectionId = this.activeSectionId + 1 < this.sections.length && this.activeSectionId + 1, this.activeSection = this.sections[this.activeSectionId], this.activeSection.classList.add(this.options.activeClass); for (let e = 0; e < this.sections.length; e++)document.documentElement.classList.remove(`fp-section-${e}`); document.documentElement.classList.add(`fp-section-${this.activeSectionId}`), !1 !== this.previousSectionId ? (this.previousSection = this.sections[this.previousSectionId], this.previousSection.classList.add(this.options.previousClass)) : this.previousSection = !1, !1 !== this.nextSectionId ? (this.nextSection = this.sections[this.nextSectionId], this.nextSection.classList.add(this.options.nextClass)) : this.nextSection = !1 } removeEffectsClasses() { switch (this.options.mode) { case "slider": this.wrapper.classList.remove("slider-mode"); break; case "cards": this.wrapper.classList.remove("cards-mode"), this.setZIndex(); break; case "fade": this.wrapper.classList.remove("fade-mode"), this.setZIndex() } } setEffectsClasses() { switch (this.options.mode) { case "slider": this.wrapper.classList.add("slider-mode"); break; case "cards": this.wrapper.classList.add("cards-mode"), this.setZIndex(); break; case "fade": this.wrapper.classList.add("fade-mode"), this.setZIndex() } } setStyle() { switch (this.options.mode) { case "slider": this.styleSlider(); break; case "cards": this.styleCards(); break; case "fade": this.styleFade() } } styleSlider() { for (let e = 0; e < this.sections.length; e++) { const t = this.sections[e]; e === this.activeSectionId ? t.style.transform = "translate3D(0,0,0)" : e < this.activeSectionId ? t.style.transform = "translate3D(0,-100%,0)" : e > this.activeSectionId && (t.style.transform = "translate3D(0,100%,0)") } } styleCards() { for (let e = 0; e < this.sections.length; e++) { const t = this.sections[e]; e >= this.activeSectionId ? t.style.transform = "translate3D(0,0,0)" : e < this.activeSectionId && (t.style.transform = "translate3D(0,-100%,0)") } } styleFade() { for (let e = 0; e < this.sections.length; e++) { const t = this.sections[e]; e === this.activeSectionId ? (t.style.opacity = "1", t.style.pointerEvents = "all") : (t.style.opacity = "0", t.style.pointerEvents = "none") } } removeStyle() { for (let e = 0; e < this.sections.length; e++) { const t = this.sections[e]; t.style.opacity = "", t.style.visibility = "", t.style.transform = "" } } checkScroll(e, t) { if (this.goScroll = !1, !this.stopEvent && t && (this.goScroll = !0, this.haveScroll(t))) { this.goScroll = !1; const s = Math.round(t.scrollHeight - t.scrollTop); (Math.abs(s - t.scrollHeight) < 2 && e <= 0 || Math.abs(s - t.clientHeight) < 2 && e >= 0) && (this.goScroll = !0) } } haveScroll(e) { return e.scrollHeight !== window.innerHeight } removeClasses() { for (let e = 0; e < this.sections.length; e++) { const t = this.sections[e]; t.classList.remove(this.options.activeClass), t.classList.remove(this.options.previousClass), t.classList.remove(this.options.nextClass) } } events() { this.events = { wheel: this.wheel.bind(this), touchdown: this.touchDown.bind(this), touchup: this.touchUp.bind(this), touchmove: this.touchMove.bind(this), touchcancel: this.touchUp.bind(this), transitionEnd: this.transitionend.bind(this), click: this.clickBullets.bind(this) }, t.iOS() && document.addEventListener("touchmove", (e => { e.preventDefault() })), this.setEvents() } setEvents() { this.wrapper.addEventListener("wheel", this.events.wheel), this.wrapper.addEventListener("touchstart", this.events.touchdown), this.options.bullets && this.bulletsWrapper && this.bulletsWrapper.addEventListener("click", this.events.click) } removeEvents() { this.wrapper.removeEventListener("wheel", this.events.wheel), this.wrapper.removeEventListener("touchdown", this.events.touchdown), this.wrapper.removeEventListener("touchup", this.events.touchup), this.wrapper.removeEventListener("touchcancel", this.events.touchup), this.wrapper.removeEventListener("touchmove", this.events.touchmove), this.bulletsWrapper && this.bulletsWrapper.removeEventListener("click", this.events.click) } clickBullets(e) { const t = e.target.closest(`.${this.options.bulletClass}`); if (t) { const e = Array.from(this.bulletsWrapper.children).indexOf(t); this.switchingSection(e) } } setActiveBullet(e) { if (!this.bulletsWrapper) return; const t = this.bulletsWrapper.children; for (let s = 0; s < t.length; s++) { const i = t[s]; e === s ? i.classList.add(this.options.bulletActiveClass) : i.classList.remove(this.options.bulletActiveClass) } } touchDown(e) { this._yP = e.changedTouches[0].pageY, this._eventElement = e.target.closest(`.${this.options.activeClass}`), this._eventElement && (this._eventElement.addEventListener("touchend", this.events.touchup), this._eventElement.addEventListener("touchcancel", this.events.touchup), this._eventElement.addEventListener("touchmove", this.events.touchmove), this.clickOrTouch = !0, t.iOS() && (this._eventElement.scrollHeight !== this._eventElement.clientHeight && (0 === this._eventElement.scrollTop && (this._eventElement.scrollTop = 1), this._eventElement.scrollTop === this._eventElement.scrollHeight - this._eventElement.clientHeight && (this._eventElement.scrollTop = this._eventElement.scrollHeight - this._eventElement.clientHeight - 1)), this.allowUp = this._eventElement.scrollTop > 0, this.allowDown = this._eventElement.scrollTop < this._eventElement.scrollHeight - this._eventElement.clientHeight, this.lastY = e.changedTouches[0].pageY)) } touchMove(e) { const s = e.target.closest(`.${this.options.activeClass}`); if (t.iOS()) { let t = e.changedTouches[0].pageY > this.lastY, i = !t; this.lastY = e.changedTouches[0].pageY, s && (t && this.allowUp || i && this.allowDown ? e.stopPropagation() : e.cancelable && e.preventDefault()) } if (!this.clickOrTouch || e.target.closest(this.options.noEventSelector)) return; let i = this._yP - e.changedTouches[0].pageY; this.checkScroll(i, s), this.goScroll && Math.abs(i) > 20 && this.choiceOfDirection(i) } touchUp(e) { return this._eventElement.removeEventListener("touchend", this.events.touchup), this._eventElement.removeEventListener("touchcancel", this.events.touchup), this._eventElement.removeEventListener("touchmove", this.events.touchmove), this.clickOrTouch = !1 } transitionend(e) { this.stopEvent = !1, document.documentElement.classList.remove(this.options.wrapperAnimatedClass), this.wrapper.classList.remove(this.options.wrapperAnimatedClass) } wheel(e) { if (e.target.closest(this.options.noEventSelector)) return; const t = e.deltaY, s = e.target.closest(`.${this.options.activeClass}`); this.checkScroll(t, s), this.goScroll && this.choiceOfDirection(t) } choiceOfDirection(e) { e > 0 && !1 !== this.nextSection ? this.activeSectionId = this.activeSectionId + 1 < this.sections.length ? ++this.activeSectionId : this.activeSectionId : e < 0 && !1 !== this.previousSection && (this.activeSectionId = this.activeSectionId - 1 >= 0 ? --this.activeSectionId : this.activeSectionId), this.switchingSection(this.activeSectionId, e) } switchingSection(e = this.activeSectionId, t) { if (t || (e < this.activeSectionId ? t = -100 : e > this.activeSectionId && (t = 100)), this.activeSectionId = e, this.stopEvent = !0, (!1 === this.previousSectionId && t < 0 || !1 === this.nextSectionId && t > 0) && (this.stopEvent = !1), this.stopEvent) { let e; document.documentElement.classList.add(this.options.wrapperAnimatedClass), this.wrapper.classList.add(this.options.wrapperAnimatedClass), this.removeClasses(), this.setClasses(), this.setStyle(), this.options.bullets && this.setActiveBullet(this.activeSectionId), t < 0 ? (e = this.activeSection.dataset.fpDirectionUp ? parseInt(this.activeSection.dataset.fpDirectionUp) : 500, document.documentElement.classList.add("fp-up"), document.documentElement.classList.remove("fp-down")) : (e = this.activeSection.dataset.fpDirectionDown ? parseInt(this.activeSection.dataset.fpDirectionDown) : 500, document.documentElement.classList.remove("fp-up"), document.documentElement.classList.add("fp-down")), setTimeout((() => { this.events.transitionEnd() }), e), this.options.onSwitching(this), document.dispatchEvent(new CustomEvent("fpswitching", { detail: { fp: this } })) } } setBullets() { if (this.bulletsWrapper = document.querySelector(`.${this.options.bulletsClass}`), !this.bulletsWrapper) { const e = document.createElement("div"); e.classList.add(this.options.bulletsClass), this.wrapper.append(e), this.bulletsWrapper = e } if (this.bulletsWrapper) for (let e = 0; e < this.sections.length; e++) { const e = document.createElement("span"); e.classList.add(this.options.bulletClass), this.bulletsWrapper.append(e) } } setZIndex() { let e = this.sections.length; for (let t = 0; t < this.sections.length; t++) { this.sections[t].style.zIndex = e, --e } } removeZIndex() { for (let e = 0; e < this.sections.length; e++) { this.sections[e].style.zIndex = "" } } } document.querySelector("[data-fp]") && (e.fullpage = new ht(document.querySelector("[data-fp]"), "")); let ut = !1; setTimeout((() => { if (ut) { let e = new Event("windowScroll"); window.addEventListener("scroll", (function (t) { document.dispatchEvent(e) })) } }), 0); new class { constructor(e) { this.type = e } init() { this.оbjects = [], this.daClassname = "_dynamic_adapt_", this.nodes = [...document.querySelectorAll("[data-da]")], this.nodes.forEach((e => { const t = e.dataset.da.trim().split(","), s = {}; s.element = e, s.parent = e.parentNode, s.destination = document.querySelector(`${t[0].trim()}`), s.breakpoint = t[1] ? t[1].trim() : "767", s.place = t[2] ? t[2].trim() : "last", s.index = this.indexInParent(s.parent, s.element), this.оbjects.push(s) })), this.arraySort(this.оbjects), this.mediaQueries = this.оbjects.map((({ breakpoint: e }) => `(${this.type}-width: ${e}px),${e}`)).filter(((e, t, s) => s.indexOf(e) === t)), this.mediaQueries.forEach((e => { const t = e.split(","), s = window.matchMedia(t[0]), i = t[1], n = this.оbjects.filter((({ breakpoint: e }) => e === i)); s.addEventListener("change", (() => { this.mediaHandler(s, n) })), this.mediaHandler(s, n) })) } mediaHandler(e, t) { e.matches ? t.forEach((e => { this.moveTo(e.place, e.element, e.destination) })) : t.forEach((({ parent: e, element: t, index: s }) => { t.classList.contains(this.daClassname) && this.moveBack(e, t, s) })) } moveTo(e, t, s) { t.classList.add(this.daClassname), "last" === e || e >= s.children.length ? s.append(t) : "first" !== e ? s.children[e].before(t) : s.prepend(t) } moveBack(e, t, s) { t.classList.remove(this.daClassname), void 0 !== e.children[s] ? e.children[s].before(t) : e.append(t) } indexInParent(e, t) { return [...e.children].indexOf(t) } arraySort(e) { "min" === this.type ? e.sort(((e, t) => e.breakpoint === t.breakpoint ? e.place === t.place ? 0 : "first" === e.place || "last" === t.place ? -1 : "last" === e.place || "first" === t.place ? 1 : 0 : e.breakpoint - t.breakpoint)) : e.sort(((e, t) => e.breakpoint === t.breakpoint ? e.place === t.place ? 0 : "first" === e.place || "last" === t.place ? 1 : "last" === e.place || "first" === t.place ? -1 : 0 : t.breakpoint - e.breakpoint)) } }("max").init(); document.querySelectorAll(".product-page__box").forEach((e => { e.addEventListener("click", (function (t) { e.classList.add("new"), document.querySelectorAll(".product-page__after").forEach((e => { e.closest(".new") && (e.style.cssText = "\n            left: 0;\n             opacity: 1;\n            ") })), t.preventDefault() })) })), window.FLS = !1, function (e) { let t = new Image; t.onload = t.onerror = function () { e(2 == t.height) }, t.src = "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA" }((function (e) { let t = !0 === e ? "webp" : "no-webp"; document.documentElement.classList.add(t) })), document.querySelector(".icon-menu") && document.addEventListener("click", (function (e) { r && e.target.closest(".icon-menu") && (((e = 500) => { document.documentElement.classList.contains("lock") ? o(e) : a(e) })(), document.documentElement.classList.toggle("menu-open")) })), window.addEventListener("load", (function (e) { const t = document.querySelectorAll("[data-showmore]"); let s, r; function o(e) { e.forEach((e => { a(e.itemsArray, e.matchMedia) })) } function a(e, t) { e.forEach((e => { !function (e, t = !1) { let s = (e = t ? e.item : e).querySelectorAll("[data-showmore-content]"), r = e.querySelectorAll("[data-showmore-button]"); s = Array.from(s).filter((t => t.closest("[data-showmore]") === e))[0], r = Array.from(r).filter((t => t.closest("[data-showmore]") === e))[0]; const o = l(e, s); (t.matches || !t) && o < c(s) ? (i(s, 0, e.classList.contains("_showmore-active") ? c(s) : o), r.hidden = !1) : (n(s, 0, o), r.hidden = !0) }(e, t) })) } function l(e, t) { let s = 0; const i = e.dataset.showmore ? e.dataset.showmore : "size", n = parseFloat(getComputedStyle(t).rowGap) ? parseFloat(getComputedStyle(t).rowGap) : 0; if ("items" === i) { const e = t.dataset.showmoreContent ? t.dataset.showmoreContent : 3, i = t.children; for (let t = 1; t < i.length; t++) { const n = i[t - 1], r = parseFloat(getComputedStyle(n).marginTop) ? parseFloat(getComputedStyle(n).marginTop) : 0, o = parseFloat(getComputedStyle(n).marginBottom) ? parseFloat(getComputedStyle(n).marginBottom) : 0; if (s += n.offsetHeight + r, t == e) break; s += o } n && (s += (e - 1) * n) } else s = t.dataset.showmoreContent ? t.dataset.showmoreContent : 150; return s } function c(e) { let t, s = e.offsetHeight; e.style.removeProperty("height"), e.closest("[hidden]") && (t = e.closest("[hidden]"), t.hidden = !1); let i = e.offsetHeight; return t && (t.hidden = !0), e.style.height = `${s}px`, i } function p(e) { const t = e.target, c = e.type; if ("click" === c) { if (t.closest("[data-showmore-button]")) { const e = t.closest("[data-showmore-button]").closest("[data-showmore]"), s = e.querySelector("[data-showmore-content]"), r = e.dataset.showmoreButton ? e.dataset.showmoreButton : "500", o = l(e, s); s.classList.contains("_slide") || (e.classList.contains("_showmore-active") ? i(s, r, o) : n(s, r, o), e.classList.toggle("_showmore-active")) } } else "resize" === c && (s && s.length && a(s), r && r.length && o(r)) } t.length && (s = Array.from(t).filter((function (e, t, s) { return !e.dataset.showmoreMedia })), s.length && a(s), document.addEventListener("click", p), window.addEventListener("resize", p), r = d(t, "showmoreMedia"), r && r.length && (r.forEach((e => { e.matchMedia.addEventListener("change", (function () { a(e.itemsArray, e.matchMedia) })) })), o(r))) })), function (e = { viewPass: !1, autoHeight: !1 }) { if (document.body.addEventListener("focusin", (function (e) { const t = e.target; "INPUT" !== t.tagName && "TEXTAREA" !== t.tagName || (t.hasAttribute("data-no-focus-classes") || (t.classList.add("_form-focus"), t.parentElement.classList.add("_form-focus")), p.removeError(t), t.hasAttribute("data-validate") && p.removeError(t)) })), document.body.addEventListener("focusout", (function (e) { const t = e.target; "INPUT" !== t.tagName && "TEXTAREA" !== t.tagName || (t.hasAttribute("data-no-focus-classes") || (t.classList.remove("_form-focus"), t.parentElement.classList.remove("_form-focus")), t.hasAttribute("data-validate") && p.validateInput(t)) })), e.viewPass && document.addEventListener("click", (function (e) { let t = e.target; if (t.closest('[class*="__viewpass"]')) { let e = t.classList.contains("_viewpass-active") ? "password" : "text"; t.parentElement.querySelector("input").setAttribute("type", e), t.classList.toggle("_viewpass-active") } })), e.autoHeight) { const t = document.querySelectorAll("textarea[data-autoheight]"); if (t.length) { function s(e, t) { e.style.height = `${t}px` } t.forEach((e => { const t = e.hasAttribute("data-autoheight-min") ? Number(e.dataset.autoheightMin) : Number(e.offsetHeight), i = e.hasAttribute("data-autoheight-max") ? Number(e.dataset.autoheightMax) : 1 / 0; s(e, Math.min(t, i)), e.addEventListener("input", (() => { e.scrollHeight > t && (e.style.height = "auto", s(e, Math.min(Math.max(e.scrollHeight, t), i))) })) })) } } }({ viewPass: !1, autoHeight: !1 }), function () { const e = document.querySelectorAll(".rating"); e.length > 0 && function () { let t, s; for (let t = 0; t < e.length; t++) { i(e[t]) } function i(e) { n(e), r(), e.classList.contains("rating_set") && o(e) } function n(e) { t = e.querySelector(".rating__active"), s = e.querySelector(".rating__value") } function r(e = s.innerHTML) { const i = e / .05; t.style.width = `${i}%` } function o(e) { const t = e.querySelectorAll(".rating__item"); for (let i = 0; i < t.length; i++) { const o = t[i]; o.addEventListener("mouseenter", (function (t) { n(e), r(o.value) })), o.addEventListener("mouseleave", (function (e) { r() })), o.addEventListener("click", (function (t) { n(e), e.dataset.ajax ? a(o.value, e) : (s.innerHTML = i + 1, r()) })) } } async function a(e, t) { if (!t.classList.contains("rating_sending")) { t.classList.add("rating_sending"); let e = await fetch("rating.json", { method: "GET" }); if (e.ok) { const i = (await e.json()).newRating; s.innerHTML = i, r(), t.classList.remove("rating_sending") } else alert("Помилка"), t.classList.remove("rating_sending") } } }() }() })() })();